\documentclass[a4paper]{article}
\usepackage{vntex}

\usepackage{a4wide,amssymb,epsfig,latexsym,multicol,array,hhline,fancyhdr}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{lastpage}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{enumerate}
\usepackage{color}
\usepackage{graphicx}
\usepackage{array}
\usepackage{tabularx, caption}
\usepackage{multirow}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{multicol}
\usepackage{rotating}
\usepackage{graphics}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{epsfig}
\usepackage{tikz}
\usepackage{float}
\usepackage{placeins}
\usepackage{listings}
\usetikzlibrary{arrows,snakes,backgrounds}
\usepackage{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=black,colorlinks=true }
\usepackage{array}
\usepackage{enumitem}  % để dùng [noitemsep,leftmargin=*]

\newtheorem{theorem}{{\bf Định lý}}
\newtheorem{property}{{\bf Tính chất}}
\newtheorem{proposition}{{\bf Mệnh đề}}
\newtheorem{corollary}[proposition]{{\bf Hệ quả}}
\newtheorem{lemma}[proposition]{{\bf Bổ đề}}

\everymath{\color{blue}}
\setlength{\headheight}{40pt}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{
    \begin{tabular}{rl}
        \begin{picture}(25,15)(0,0)
            \put(0,-8){\includegraphics[width=8mm, height=8mm]{logoITSGUsmall.png}}
        \end{picture}&
        \begin{tabular}{l}
            \textbf{\bf \ttfamily Trường Đại học Sài Gòn}\\
            \textbf{\bf \ttfamily Khoa Công Nghệ Thông Tin}
        \end{tabular}
    \end{tabular}
}
\fancyhead[R]{
    \begin{tabular}{l}
        \tiny \bf \\
        \tiny \bf
    \end{tabular}  }
\fancyfoot{} % clear all footer fields
\fancyfoot[L]{\scriptsize \ttfamily Bài tập lớn môn Kiểm Thử Phần Mềm - Niên khóa 2025-2026}
\fancyfoot[R]{\scriptsize \ttfamily Trang {\thepage}/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}

%%%
\setcounter{secnumdepth}{0} % Tắt đánh số tự động cho tất cả các cấp
\setcounter{tocdepth}{3}
\makeatletter
\newcounter {subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection .\@alph\c@subsubsubsection}
\newcommand\subsubsubsection{\@startsection{subsubsubsection}{4}{\z@}%
{-3.25ex\@plus -1ex \@minus -.2ex}%
{1.5ex \@plus .2ex}%
{\normalfont\normalsize\bfseries}}
\newcommand*\l@subsubsubsection{\@dottedtocline{3}{10.0em}{4.1em}}
\newcommand*{\subsubsubsectionmark}[1]{}
\makeatother

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
    language=Java, % Changed to Java for Backend tests, can be changed to JavaScript
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3,
    numbers=left,
    stepnumber=1,
    numbersep=1pt,
    firstnumber=1,
    numberfirstline=true
}

\begin{document}

    \begin{titlepage}
        \begin{center}
            TRƯỜNG ĐẠI HỌC SÀI GÒN \\
            KHOA CÔNG NGHỆ THÔNG TIN
        \end{center}

        \vspace{0.5cm}

        \begin{center}
            \includegraphics[width=3.5cm]{logoITSGU.png}
        \end{center}

        \vspace{1cm}

        \begin{center}
% Sử dụng tabularx hoặc đơn giản là tabular thường nhưng bỏ multicolumn thừa
            \begin{tabular}{c}
                \multicolumn{1}{c}{\textbf{{\Huge KIỂM THỬ PHẦN MỀM}}}\\
                \\
                \hline
                \\
                \textbf{{\Large ĐỀ TÀI :}}\\ % Thêm dòng này cho rõ nghĩa (tùy chọn)
                \textbf{{\huge Ứng dụng Đăng nhập \& Quản lý Sản phẩm}}\\
                \textbf{{\Large (Login \& Product Management - Version 1.0)}}\\
                \\
                \hline
            \end{tabular}
        \end{center}

        \vspace{2cm}

% --- PHẦN SỬA LỖI CANH LỀ ---
        \begin{table}[h]
            \centering
% Dùng 2 cột: r (right - canh phải cho nhãn) và l (left - canh trái cho tên)
            \begin{tabular}{rl}
                \textbf{GIẢNG VIÊN:} & Từ Lãng Phiêu \\
                \textbf{NHÓM:} & 18 \\
                \textbf{SINH VIÊN:}   & Nguyễn Thanh Phú- 3123410269 \\
                & Nhan Chí Phong - 3123560062 \\
                & Hoàng Đình Phú Quý - 3123560074 \\
                & Nguyễn Thành Long - 3121410298\\
                & Võ văn Tài -  3123410321 \\
            \end{tabular}
        \end{table}
% ----------------------------

        \vspace{2cm}
        \begin{center}
        {\footnotesize TP. HỒ CHÍ MINH, THÁNG 11/2025}
        \end{center}

    \end{titlepage}

    \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage
    \tableofcontents
    \newpage

    \newpage
    \thispagestyle{empty}
    \vspace*{\fill}
    \begin{center}
        \section*{Đóng Góp Của Các Thành Viên }

        \begin{table}[h!]
            \centering
            \begin{tabular}{|p{0.3\textwidth}|p{0.25\textwidth}|p{0.15\textwidth}|p{0.3\textwidth}|}
                \hline
                \textbf{Thành viên} & \textbf{Chức vụ} & \textbf{Phần trăm} & \textbf{Đóng góp} \\
                \hline
                Nguyễn Thanh Phú & Trưởng nhóm & 25\% & Câu 1, viết báo cáo , cover câu 4  \\
                \hline
                Hoàng Đình Phú Quý  & Thành viên & 30\% & Câu 5, Mở rộng , cover câu 2, viết báo cáo \\
                \hline
                Nhan Chí Phong & Thành viên & 25\% & Câu 3 , viết báo cáo , cover team \\
                \hline
                Võ Văn Tài & Thành viên & 10\% & Câu 4 \\
                \hline
                Nguyễn Thành Long & Thành viên & 10\% & Câu 2 \\
                \hline
            \end{tabular}
        \end{table}
    \end{center}
    \vspace*{\fill}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage

    \section{GIỚI THIỆU DỰ ÁN}

    \subsection{Tổng quan}
    Dự án \textbf{FloginFE\_BE} là một ứng dụng web full-stack được phát triển để thực hành các kỹ thuật kiểm thử phần mềm. Hệ thống bao gồm các chức năng chính:
    \begin{itemize}
        \item \textbf{Login:} Hệ thống đăng nhập bảo mật với validation chặt chẽ.
        \item \textbf{Product Management:} Quản lý sản phẩm với đầy đủ các thao tác CRUD (Create, Read, Update, Delete).
    \end{itemize}

    \subsection{Công nghệ sử dụng}
    \begin{itemize}
        \item \textbf{Frontend:} React 18+, Jest, React Testing Library.
        \item \textbf{Backend:} Spring Boot 3.2+, JUnit 5, Mockito.
        \item \textbf{Database:} MySQL.
        \item \textbf{CI/CD:} GitHub Actions.
    \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage

    \section{CÂU 1: PHÂN TÍCH VÀ THIẾT KẾ TEST CASES}

    \subsection{Câu 1.1: Login - Phân tích và Test Scenarios (10 điểm)}

    \subsubsection{Yêu cầu (5 điểm)}

    \paragraph{a) Phân tích yêu cầu chức năng Login (2 điểm)}

    \textbf{Validation rules cho username:}
    \begin{itemize}
        \item Độ dài: 3-50 ký tự
        \item Định dạng cho phép: chữ cái (a-z, A-Z), số (0-9), và các ký tự -, ., \_
        \item Không chấp nhận: khoảng trắng, kí tự đặc biệt khác, icon
    \end{itemize}

    \textbf{Validation rules cho password:}
    \begin{itemize}
        \item Độ dài: 6-100 ký tự
        \item Phải chứa ít nhất 1 chữ cái và 1 số
        \item Có thể chứa ký tự đặc biệt (không được quy định cấm)
    \end{itemize}

    \textbf{Authentication flow:}
    \begin{itemize}
        \item Người dùng nhập username và password
        \item Hệ thống validate định dạng input
        \item Nếu validation thất bại → hiển thị thông báo định dạng đúng
        \item Nếu validation thành công → kiểm tra thông tin trong database
        \item Nếu thông tin khớp → tạo session/chuyển hướng đến trang chủ
        \item Nếu không khớp → hiển thị thông báo lỗi
    \end{itemize}

    \textbf{Error handling:}
    \begin{itemize}
        \item Hiển thị thông báo lỗi cụ thể cho từng trường hợp (server phản hồi)
        \item Giữ nguyên giá trị đã nhập (trừ password)
        \item Log lỗi cho mục đích bảo mật và debugging
    \end{itemize}

    \paragraph{b) Test Scenarios cho Login (2 điểm)}

    \begin{enumerate}
        \item \textbf{Happy Path:} Đăng nhập thành công
        \begin{itemize}
            \item Input: Username: "admin123", Password: "admin123"
            \item Expected: Đăng nhập thành công, chuyển hướng đến trang chủ
        \end{itemize}

        \item \textbf{Negative Test:} Username rỗng
        \begin{itemize}
            \item Input: Username: "", Password: "admin123"
            \item Expected: Hiển thị lỗi "Username không được để trống"
        \end{itemize}

        \item \textbf{Negative Test:} Password rỗng
        \begin{itemize}
            \item Input: Username: "admin123", Password: ""
            \item Expected: Hiển thị lỗi "Mật khẩu không được để trống"
        \end{itemize}

        \item \textbf{Negative Test:} Sai username/password
        \begin{itemize}
            \item Input: Username: "wronguser", Password: "wrongpass"
            \item Expected: Hiển thị lỗi "Thông tin đăng nhập không chính xác"
        \end{itemize}

        \item \textbf{Boundary Test:} Username đạt min length
        \begin{itemize}
            \item Input: Username: "abc", Password: "pass123"
            \item Expected: Đăng nhập thành công
        \end{itemize}

        \item \textbf{Boundary Test:} Username đạt max length
        \begin{itemize}
            \item Input: Username: "a"*50, Password: "pass123"
            \item Expected: Đăng nhập thành công
        \end{itemize}

        \item \textbf{Boundary Test:} Password đạt min length
        \begin{itemize}
            \item Input: Username: "user123", Password: "abc123"
            \item Expected: Đăng nhập thành công
        \end{itemize}

        \item \textbf{Boundary Test:} Password đạt max length
        \begin{itemize}
            \item Input: Username: "user123", Password: "a"*99 + "1"
            \item Expected: Đăng nhập thành công
        \end{itemize}

        \item \textbf{Edge Case:} Username chứa ký tự không hợp lệ
        \begin{itemize}
            \item Input: Username: "user@123!", Password: "pass123"
            \item Expected: Hiển thị lỗi "Username chỉ được chứa chữ cái, số và ký tự -.\_"
        \end{itemize}

        \item \textbf{Edge Case:} Password chỉ chứa chữ (thiếu số)
        \begin{itemize}
            \item Input: Username: "user123", Password: "test"
            \item Expected: Hiển thị lỗi "Mật khẩu phải chứa ít nhất 1 chữ cái và 1 số"
        \end{itemize}

        \item \textbf{Security Test:} SQL Injection attack
        \begin{itemize}
            \item Input: Username: admin' OR '1'='1'--, Password: anything
            \item Expected: Hiển thị thông báo lỗi "Thông tin đăng nhập không chính xác", KHÔNG tiết lộ thông tin lỗi database, hệ thống không bị crash hoặc bypass authentication
        \end{itemize}

        \item \textbf{Security Test:} XSS Script Injection
        \begin{itemize}
            \item Input: Username: <script>alert('hello')</script>, Password: password123
            \item Expected: Hiển thị lỗi validation "Username chỉ được chứa chữ cái, số và ký tự -.\_", Script không được thực thi trên trình duyệt
        \end{itemize}
    \end{enumerate}

    \paragraph{c) Phân loại ưu tiên test scenarios (1 điểm)}

    \begin{itemize}
        \item \textbf{Critical (Rất quan trọng):} Scenario 1, 2, 3, 4, 11, 12
        \item \textbf{High (Cao):} Scenario 5, 6, 9
        \item \textbf{Medium (Trung bình):} Scenario 7, 8
        \item \textbf{Low (Thấp):} Scenario 10
    \end{itemize}

    \textbf{Giải thích:}
    \begin{itemize}
        \item Critical: Các scenario ảnh hưởng trực tiếp đến khả năng sử dụng hệ thống và bảo mật
        \item High: Các scenario liên quan đến core validation rules của username
        \item Medium: Các scenario về password validation, ít xảy ra hơn trong thực tế
        \item Low: Các trường hợp edge case ít gặp, ưu tiên thấp hơn
    \end{itemize}

    \subsubsection{Thiết kế Test Cases chi tiết (5 điểm)}
% ================== LOGIN TEST CASES ==================
    \begin{table}[htbp]
        \small
        \centering
        \begin{tabular}{|>{\arraybackslash}p{4cm}|p{10cm}|}
            \hline
            \textbf{Test Case ID} & TC\_LOGIN\_001 \\ \hline
            \textbf{Test Name} & Đăng nhập thành công với credentials hợp lệ \\ \hline
            \textbf{Priority} & Quan trọng \\ \hline
            \textbf{Preconditions} &
            \begin{itemize}[leftmargin=*,noitemsep]
                \item Tài khoản tồn tại trong hệ thống
                \item Ứng dụng đang chạy
            \end{itemize} \\ \hline
            \textbf{Test Steps} &
            \begin{enumerate}[leftmargin=*,noitemsep]
                \item Vào trang login
                \item Nhập username
                \item Nhập password
                \item Click nút Login
            \end{enumerate} \\ \hline
            \textbf{Test Data} & Username: admin123 \newline Password: admin123 \\ \hline
            \textbf{Expected Result} &
            \begin{itemize}[leftmargin=*,noitemsep]
                \item Hiển thị welcome message
                \item Token/Session được lưu
                \item Chuyển hướng đến trang quản lý sản phẩm
            \end{itemize} \\ \hline
            \textbf{Actual Result} & (Để trống) \\ \hline
            \textbf{Status} & Not Run \\ \hline
        \end{tabular}
        \caption{Test Case Đăng nhập thành công}
    \end{table}

    \begin{table}[htbp]
        \small
        \centering
        \begin{tabular}{|p{2.8cm}|p{10.2cm}|}
            \hline
            \textbf{Test Case ID} & TC\_LOGIN\_002 \\ \hline
            \textbf{Test Name} & Đăng nhập thất bại khi username rỗng \\ \hline
            \textbf{Priority} & Quan trọng \\ \hline
            \textbf{Preconditions} & Ứng dụng đang chạy \\ \hline
            \textbf{Test Steps} &
            \begin{enumerate}[leftmargin=*,noitemsep]
                \item Vào trang login
                \item Không nhập username
                \item Nhập password
                \item Click nút Login
            \end{enumerate} \\ \hline
            \textbf{Test Data} & Username: (rỗng) \newline Password: Test123 \\ \hline
            \textbf{Expected Result} &
            \begin{itemize}[leftmargin=*,noitemsep]
                \item Hiển thị thông báo lỗi: ``Username không được để trống''
                \item Vẫn ở trang login
                \item Không tạo session/token
            \end{itemize} \\ \hline
            \textbf{Actual Result} & (Để trống) \\ \hline
            \textbf{Status} & Not Run \\ \hline
        \end{tabular}
        \caption{Test Case Đăng nhập thất bại khi username rỗng}
    \end{table}


    \begin{table}[htbp]
        \small
        \centering
        \begin{tabular}{|p{2.8cm}|p{10.2cm}|}
            \hline
            \textbf{Test Case ID} & TC\_LOGIN\_003 \\ \hline
            \textbf{Test Name} & Đăng nhập thất bại Password rỗng \\ \hline
            \textbf{Priority} & Quan trọng \\ \hline
            \textbf{Preconditions} & Ứng dụng đang chạy, đang ở trang login \\ \hline
            \textbf{Test Steps} &
            \begin{enumerate}[leftmargin=*,noitemsep]
                \item Vào trang login
                \item Nhập username đúng định dạng
                \item Không nhập  password
                \item Click nút Login
            \end{enumerate} \\ \hline
            \textbf{Test Data} & Username: admin123 \newline Password\\ \hline
            \textbf{Expected Result} &
            \begin{itemize}[leftmargin=*,noitemsep]
                \item Hiển thị thông báo lỗi: "Password không được để trống"
                \item Vẫn ở trang login
                \item Không tạo session/token
            \end{itemize} \\ \hline
            \textbf{Actual Result} & (Để trống) \\ \hline
            \textbf{Status} & Not Run \\ \hline
        \end{tabular}
        \caption{Test Case đăng nhập thất bại khi password rỗng}
    \end{table}

    \begin{table}[htbp]
        \small
        \centering
        \begin{tabular}{|p{2.8cm}|p{10.2cm}|}
            \hline
            \textbf{Test Case ID} & TC\_LOGIN\_004 \\ \hline
            \textbf{Test Name} & Đăng nhập thất bại khi password chỉ chứa chữ \\ \hline
            \textbf{Priority} & Cao \\ \hline
            \textbf{Preconditions} & Ứng dụng đang chạy \\ \hline
            \textbf{Test Steps} &
            \begin{enumerate}[leftmargin=*,noitemsep]
                \item Vào trang login
                \item Nhập username
                \item Nhập password sai định dạng
                \item Click nút Login
            \end{enumerate} \\ \hline
            \textbf{Test Data} & Username: testuser \newline Password: password \\ \hline
            \textbf{Expected Result} &
            \begin{itemize}[leftmargin=*,noitemsep]
                \item Hiển thị thông báo lỗi: ``Mật khẩu phải chứa ít nhất 1 chữ cái và 1 số''
                \item Vẫn ở trang login
                \item Giữ username, reset input password
            \end{itemize} \\ \hline
            \textbf{Actual Result} & (Để trống) \\ \hline
            \textbf{Status} & Not Run \\ \hline
        \end{tabular}
        \caption{Test Case Đăng nhập thất bại khi password chỉ chứa chữ}
    \end{table}


    \begin{table}[htbp]
        \small
        \centering
        \begin{tabular}{|p{2.8cm}|p{10.2cm}|}
            \hline
            \textbf{Test Case ID} & TC\_LOGIN\_005 \\ \hline
            \textbf{Test Name} & Đăng nhập thất bại khi username > 50 ký tự \\ \hline
            \textbf{Priority} & Trung bình \\ \hline
            \textbf{Preconditions} & Ứng dụng đang chạy \\ \hline
            \textbf{Test Steps} &
            \begin{enumerate}[leftmargin=*,noitemsep]
                \item Vào trang login
                \item Nhập username > 50 ký tự
                \item Nhập password
                \item Click nút Login
            \end{enumerate} \\ \hline
            \textbf{Test Data} & Username:abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy \newline Password: Test123 \\ \hline
            \textbf{Expected Result} &
            \begin{itemize}[leftmargin=*,noitemsep]
                \item Hiển thị lỗi: ``Username chỉ được phép từ 3-50 ký tự''
                \item Không gửi request đến server (client-side validation)
            \end{itemize} \\ \hline
            \textbf{Actual Result} & (Để trống) \\ \hline
            \textbf{Status} & Not Run \\ \hline
        \end{tabular}
        \caption{Test Case Đăng nhập thất bại khi username quá dài}
    \end{table}
    \FloatBarrier
    \subsection{Câu 1.2: Product - Phân tích và Test Scenarios (10 điểm)}

    \subsubsection{Yêu cầu (5 điểm)}

    \paragraph{a) Phân tích yêu cầu chức năng Product CRUD (2 điểm)}

    \textbf{Create - Thêm sản phẩm mới:}
    \begin{itemize}
        \item \textbf{Validation Rules:}
        \begin{itemize}
            \item Product Name: 3-100 ký tự, bắt buộc, không trùng
            \item Price: 0 -> 999.999.999
            \item Quantity: số nguyên dương
            \item Description: ≤ 500 ký tự, có thể để trống
            \item Category: Phải chọn từ danh sách có sẵn
        \end{itemize}
        \item \textbf{Business Logic:}
        \begin{itemize}
            \item Tạo mã sản phẩm tự động (nếu có)
            \item Kiểm tra trùng tên sản phẩm
            \item Tính toán tồn kho ban đầu
            \item Log hoạt động tạo sản phẩm
        \end{itemize}
    \end{itemize}

    \textbf{Read - Xem danh sách/chi tiết sản phẩm:}
    \begin{itemize}
        \item \textbf{Danh sách sản phẩm:}
        \begin{itemize}
            \item Pagination, sorting, filtering theo category
            \item Search theo tên sản phẩm
            \item Hiển thị thông tin cơ bản: tên, giá, số lượng
        \end{itemize}
        \item \textbf{Chi tiết sản phẩm:}
        \begin{itemize}
            \item Hiển thị đầy đủ thông tin sản phẩm
            \item Hiển thị ngày tạo, ngày cập nhật
            \item Ảnh sản phẩm (nếu có)
        \end{itemize}
    \end{itemize}

    \textbf{Update - Cập nhật thông tin sản phẩm:}
    \begin{itemize}
        \item \textbf{Validation:} Tương tự Create
        \item \textbf{Business Logic:}
        \begin{itemize}
            \item Cho phép cập nhật tất cả trường (trừ ID)
            \item Kiểm tra trùng tên (loại trừ chính nó)
            \item Cập nhật ngày sửa đổi
            \item Log lịch sử thay đổi
        \end{itemize}
    \end{itemize}

    \textbf{Delete - Xóa sản phẩm:}
    \begin{itemize}
        \item \textbf{Validation:}
        \begin{itemize}
            \item Sản phẩm phải tồn tại
            \item Kiểm tra ràng buộc (có đơn hàng liên quan không)
        \end{itemize}
        \item \textbf{Business Logic:}
        \begin{itemize}
            \item Soft delete (khuyến nghị) hoặc hard delete
            \item Xóa ảnh, file đính kèm (nếu có)
            \item Log hoạt động xóa
        \end{itemize}
    \end{itemize}

    \paragraph{b) Test Scenarios cho Product (2 điểm)}

    \begin{enumerate}
        \item \textbf{Happy Path:} Tạo sản phẩm mới thành công
        \begin{itemize}
            \item Input: Dữ liệu hợp lệ đầy đủ
            \item Expected: Tạo thành công, hiển thị message, xuất hiện trong danh sách
        \end{itemize}

        \item \textbf{Happy Path:} Xem chi tiết sản phẩm thành công
        \begin{itemize}
            \item Input: ID sản phẩm hợp lệ
            \item Expected: Hiển thị đầy đủ thông tin sản phẩm
        \end{itemize}

        \item \textbf{Happy Path:} Cập nhật sản phẩm thành công
        \begin{itemize}
            \item Input: Dữ liệu mới hợp lệ
            \item Expected: Cập nhật thành công, thông tin thay đổi được lưu
        \end{itemize}

        \item \textbf{Happy Path:} Xóa sản phẩm thành công
        \begin{itemize}
            \item Input: ID sản phẩm hợp lệ, không có ràng buộc
            \item Expected: Xóa thành công, sản phẩm biến mất khỏi danh sách
        \end{itemize}

        \item \textbf{Negative Test:} Tạo sản phẩm thất bại - Tên trùng
        \begin{itemize}
            \item Input: Tên sản phẩm đã tồn tại
            \item Expected: Hiển thị lỗi "Tên sản phẩm đã tồn tại"
        \end{itemize}

        \item \textbf{Negative Test:} Tạo sản phẩm thất bại - Giá âm
        \begin{itemize}
            \item Input: Price = -1000
            \item Expected: Hiển thị lỗi "Giá phải lớn hơn 0"
        \end{itemize}

        \item \textbf{Negative Test:} Cập nhật thất bại - số lượng tồn kho âm
        \begin{itemize}
            \item Input:  Stock quantity = -50

            \item Expected:  Hiển thị lỗi "Số lượng tồn kho không được âm"
        \end{itemize}

        \item \textbf{Boundary Test:} Tạo sản phẩm - Tên đạt min length
        \begin{itemize}
            \item Input: Product Name = "ABC" (3 ký tự)
            \item Expected: Tạo thành công
        \end{itemize}

        \item \textbf{Boundary Test:} Tạo sản phẩm - Price đạt max value
        \begin{itemize}
            \item Input: Price = 999,999,999
            \item Expected: Tạo thành công
        \end{itemize}

        \item \textbf{Edge Case:} Xóa sản phẩm không tồn tại
        \begin{itemize}
            \item Input: ID sản phẩm không tồn tại
            \item Expected: Hiển thị lỗi "Sản phẩm không tồn tại"
        \end{itemize}
    \end{enumerate}

    \paragraph{c) Phân loại ưu tiên test scenarios (1 điểm)}

    \begin{itemize}
        \item \textbf{Critical (Rất quan trọng):} Scenario 1, 5, 6, 7
        \item \textbf{High (Cao):} Scenario 3, 4
        \item \textbf{Medium (Trung bình):} Scenario 2, 8, 9
        \item \textbf{Low (Thấp):} Scenario 10
    \end{itemize}

    \textbf{Giải thích:}
    \begin{itemize}
        \item Critical: Các scenario ảnh hưởng trực tiếp đến business logic và data integrity
        \item High: Các chức năng core CRUD và validation quan trọng
        \item Medium: Các chức năng cơ bản và boundary tests
        \item Low: Edge case ít xảy ra trong thực tế
    \end{itemize}

    \subsubsection{Thiết kế Test Cases chi tiết (5 điểm)}

    \begin{table}[h]
        \centering
        \begin{tabular}{|p{3cm}|p{10cm}|}
            \hline
            \textbf{Test Case ID} & TC\_PRODUCT\_001 \\
            \hline
            \textbf{Test Name} & Tạo sản phẩm mới thành công \\
            \hline
            \textbf{Priority} & Quan trọng \\
            \hline
            \textbf{Preconditions} & User đã đăng nhập \\
            & User có quyền tạo sản phẩm \\
            & Danh mục "Electronics" tồn tại \\
            \hline
            \textbf{Test Steps} & 1. Chuyển đến trang quản lý sản phẩm \\
            & 2. Click thêm sản phẩm \\
            & 3. Nhập thông tin theo mẫu \\
            & 4. Click nút lưu \\
            \hline
            \textbf{Test Data} & - Name: Laptop Dell XPS 13 \\
            & - Price: 15000000 \\
            & - Quantity: 10 \\
            & - Category: Electronics \\
            & - Description: Laptop cao cấp cho doanh nhân \\
            \hline
            \textbf{Expected Result} & - Hiển thị thông báo "thêm sản phẩm thành công" \\
            & - Hiển thị sản phẩm mới trong danh sách sản phẩm \\
            \hline
            \textbf{Actual Result} & (Để trống) \\
            \hline
            \textbf{Status} & Not Run \\
            \hline
        \end{tabular}
        \caption{Test Case Tạo sản phẩm thành công}
    \end{table}

    \begin{table}[h]
        \centering
        \begin{tabular}{|p{3cm}|p{10cm}|}
            \hline
            \textbf{Test Case ID} & TC\_PRODUCT\_002 \\
            \hline
            \textbf{Test Name} & Cập nhật thông tin sản phẩm thành công \\
            \hline
            \textbf{Priority} & Cao \\
            \hline
            \textbf{Preconditions} & User đã đăng nhập \\
            & User có quyền chỉnh sửa sản phẩm \\
            & Sản phẩm "Laptop Dell XPS 13" tồn tại \\
            & Danh mục "Laptop" tồn tại \\
            \hline
            \textbf{Test Steps} & 1. Chuyển đến trang quản lý sản phẩm \\
            & 2. Click vào button sửa ở dòng sản phẩm "Laptop Dell XPS 13" \\
            & 3. Cập nhật thông tin sản phẩm \\
            & 4. Click nút lưu \\
            \hline
            \textbf{Test Data} & Name: Laptop Dell XPS 13 (2024) \\
            & Price: 16000000 \\
            & Quantity: 15 \\
            & Category: Laptop \\
            & Description: Laptop cao cấp phiên bản 2024 \\
            \hline
            \textbf{Expected Result} & - Hiển thị thông báo "Cập nhật sản phẩm thành công" \\
            & - Hiển thị thông tin mới của sản phẩm trong danh sách sản phẩm \\
            \hline
            \textbf{Actual Result} & (Để trống) \\
            \hline
            \textbf{Status} & Not Run \\
            \hline
        \end{tabular}
        \caption{Test Case Cập nhật sản phẩm thành công}
    \end{table}

    \begin{table}[h]
        \centering
        \begin{tabular}{|p{3cm}|p{10cm}|}
            \hline
            \textbf{Test Case ID} & TC\_PRODUCT\_003 \\
            \hline
            \textbf{Test Name} & Xóa sản phẩm thành công \\
            \hline
            \textbf{Priority} & Cao \\
            \hline
            \textbf{Preconditions} & User đã đăng nhập \\
            & User có quyền xóa sản phẩm \\
            & Sản phẩm " Laptop Dell XPS 13 (2024)" tồn tại \\
            & Sản phẩm không có đơn hàng liên quan \\
            \hline
            \textbf{Test Steps} & 1. Chuyển đến trang quản lý sản phẩm \\
            & 2. Click vào button xóa ở dòng sản phẩm "Test Product For Delete" \\
            & 3. Xác nhận xóa trong confirmation dialog \\
            \hline
            \textbf{Test Data} & Product Name: Laptop Dell XPS 13 (2024)\\
            \hline
            \textbf{Expected Result} & - Hiển thị confirmation dialog \\
            & - Sau khi confirm, hiển thị message: "Xóa sản phẩm thành công" \\
            & - Sản phẩm biến mất khỏi danh sách \\
            & - Không thể tìm thấy sản phẩm bằng search \\
            \hline
            \textbf{Actual Result} & (Để trống) \\
            \hline
            \textbf{Status} & Not Run \\
            \hline
        \end{tabular}
        \caption{Test Case Xóa sản phẩm thành công}
    \end{table}

    \begin{table}[h]
        \centering
        \begin{tabular}{|p{3cm}|p{10cm}|}
            \hline
            \textbf{Test Case ID} & TC\_PRODUCT\_004 \\
            \hline
            \textbf{Test Name} & Xem danh sách sản phẩm \\
            \hline
            \textbf{Priority} & Cao \\
            \hline
            \textbf{Preconditions} & User đã đăng nhập \\
            &Có ít nhất 1 sản phẩm trong hệ thống \\
            \hline
            \textbf{Test Steps} & 1. Chuyển đến trang quản lý sản phẩm \\
            \hline
            \textbf{Test Data} & (trống) \\
            \hline
            \textbf{Expected Result} & Hiển thị danh sách sản phẩm với đầy đủ thông tin \\
            \hline
            \textbf{Actual Result} & (Để trống) \\
            \hline
            \textbf{Status} & Not Run \\
            \hline
        \end{tabular}
        \caption{Test Case Xem danh sách sản phẩm}
    \end{table}

    \begin{table}[h]
        \centering
        \begin{tabular}{|p{3cm}|p{10cm}|}
            \hline
            \textbf{Test Case ID} & TC\_PRODUCT\_005 \\
            \hline
            \textbf{Test Name} & Tạo sản phẩm thất bại do trùng tên \\
            \hline
            \textbf{Priority} & Quan trọng \\
            \hline
            \textbf{Preconditions} & User đã đăng nhập \\
            & User có quyền tạo sản phẩm \\
            &Sản phẩm "Laptop Dell XPS 13" đã tồn tại \\
            \hline
            \textbf{Test Steps} & 1. Chuyển đến trang quản lý sản phẩm \\
            & 2. Click thêm sản phẩm \\
            & 3. Nhập tên trùng và các thông tin theo mẫu \\
            & 4. Click nút lưu \\
            \hline
            \textbf{Test Data} & Name: Laptop Dell XPS 13 (trùng), Price: 15000000, Quantity: 5, Category: Electronics, Description: Sản phẩm mô tả mới \\
            \hline
            \textbf{Expected Result} & - Hiển thị lỗi: "Tên sản phẩm đã tồn tại" \\
            & - Form không được submit \\
            & - Vẫn ở trang tạo sản phẩm \\
            & - Các field khác giữ nguyên giá trị đã nhập \\
            \hline
            \textbf{Actual Result} & (Để trống) \\
            \hline
            \textbf{Status} & Not Run \\
            \hline
        \end{tabular}
        \caption{Test Case Tạo sản phẩm thất bại do trùng tên}
    \end{table}
    \FloatBarrier
    \clearpage

    \section{CÂU 2: UNIT TESTING VÀ TDD}

    Nhóm áp dụng quy trình TDD (Test-Driven Development) theo chu trình: \textbf{Red} (Viết test fail) $\rightarrow$ \textbf{Green} (Viết code để pass test) $\rightarrow$ \textbf{Refactor} (Tối ưu code). Dưới đây là các unit tests chi tiết cho Frontend và Backend.

    \subsection{2.1. Frontend Unit Tests (TDD Approach)}
    Quy trình phát triển được thực hiện theo mô hình TDD: Viết kịch bản kiểm thử trước khi viết mã nguồn chức năng. Dưới đây là minh họa quy trình unit tests cho validation module của \texttt{login} và \texttt{product}.

    \subsubsection{2.1.1. Phát triển unit tests cho validation module của Login}
    \textbf{Bước 1: Red (Viết Test)} - Viết test case kiểm tra các trường hợp user. Test này sẽ thất bại vì hàm chưa có logic.

    \begin{lstlisting}[language=Java, caption={TDD Cycle 1 - Test Case (Red)}]
describe('Login Validation Tests', () => {
  describe('validateUsername', () => {
    test('TC1: Username rong - nen tra ve loi', () => {
      expect(validateUsername('')).toBe('Ten dang nhap khong duoc de trong');
    });

    test('TC2: Username qua ngan nen tra ve loi', () => {
      expect(validateUsername('ab')).toBe('Ten dang nhap phai co it nhat 3 ky tu');
    });

    test('TC3: Username qua dai - nen tra ve loi', () => {
      expect(validateUsername('a'.repeat(51))).toBe('Ten dang nhap khong duoc qua 50 ky tu');
    });

    test('TC4: Username chua ky tu dac biet khong hop le - nen tra ve loi', () => {
      expect(validateUsername('user@')).toBe('Ten dang nhap chi duoc chua chu, so va cac ky tu -, ., _');
    });

    test('TC5: Username chua ky tu dac biet khong hop le - khoang trang', () => {
      expect(validateUsername('user name')).toBe('Ten dang nhap chi duoc chua chu, so va cac ky tu -, ., _');
    });

    test('TC6: Username hop le - khong co loi', () => {
      expect(validateUsername('user123')).toBe('');
    });

    test('TC7: Username hop le voi cac ky tu duoc cho phep', () => {
      expect(validateUsername('user_123.test')).toBe('');
    });
  });

  describe('validatePassword', () => {
    test('TC8: Password rong - nen tra ve loi', () => {
      expect(validatePassword('')).toBe('Mat khau khong duoc de trong');
    });

    test('TC9: Password qua ngan - nen tra ve loi', () => {
      expect(validatePassword('12345')).toBe('Mat khau phai co it nhat 6 ky tu');
    });

    test('TC10: Password qua dai - nen tra ve loi', () => {
      expect(validatePassword('a'.repeat(101))).toBe('Mat khau khong duoc qua 100 ky tu');
    });

    test('TC11: Password khong co chu - nen tra ve loi', () => {
      expect(validatePassword('123456')).toBe('Mat khau phai chua ca chu va so');
    });

    test('TC12: Password khong co so - nen tra ve loi', () => {
      expect(validatePassword('password')).toBe('Mat khau phai chua ca chu va so');
    });

    test('TC13: Password hop le - khong co loi', () => {
      expect(validatePassword('password123')).toBe('');
    });

    test('TC14: Password hop le voi ky tu dac biet', () => {
      expect(validatePassword('Pass123!')).toBe('');
    });
  });
});
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{FrontendValidationTestTDD-RED.png}
        \caption{Kết quả chạy test thất bại (Phase Red) khi chưa cài đặt logic}
        \label{fig:test-fail}
    \end{figure}

    \textbf{Bước 2: Green (Viết Code)} - Viết mã nguồn để test case trên thông qua (Passed).

    \begin{lstlisting}[language=Java, caption={TDD Cycle 1 - Implementation (Green)}]
export const validateUsername = (username) => {
  if (!username || username.trim() === '') {
    return 'Ten dang nhap khong duoc de trong';
  }
  if (username.length < 3) {
    return 'Ten dang nhap phai co it nhat 3 ky tu';
  }
  if (username.length > 50) {
    return 'Ten dang nhap khong duoc qua 50 ky tu';
  }
  const regex = /^[a-zA-Z0-9]+$/;
  if (!regex.test(username)) {
    return 'Ten dang nhap chi duoc chua chu, so va cac ky tu -, ., _';
  }
  return '';
};

export const validatePassword = (password) => {
  if (!password || password.trim() === '') {
    return 'Mat khau khong duoc de trong';
  }
  if (password.length < 6) {
    return 'Mat khau phai co it nhat 6 ky tu';
  }
  if (password.length > 100) {
    return 'Mat khau khong duoc qua 100 ky tu';
  }
  const regex = /(?=.*[A-Za-z])(?=.*\d)/;
  if (!regex.test(password)) {
    return 'Mat khau phai chua ca chu va so';
  }
  return '';
};
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{FrontendValidationTestTDD-Green.png}
        \caption{Kết quả kiểm thử thành công (All Passed) và báo cáo độ phủ mã nguồn đạt 100\%}
        \label{fig:test-pass}
    \end{figure}

    \textbf{Bước 3: Refactor (Tối ưu hóa)} - Sau khi tất cả các test đã xanh (Green), tiến hành tối ưu hóa mã nguồn để gọn gàng hơn mà không làm thay đổi hành vi (Logic đã được bảo đảm bởi bộ test)

    \begin{lstlisting}[language=Java, caption={TDD Cycle 1 - Final Refactored Code (Refactor)}]
export const validateUsername = (username) => {
  if (!username || username.trim() === '') {
    return 'Ten dang nhap khong duoc de trong';
  }
  if (username.length < 3 || username.length > 50) {
    return 'Ten dang nhap phai co tu 3-50 ky tu';
  }
  if (!/^[a-zA-Z0-9._-]+$/.test(username)) {
    return 'Ten dang nhap chi duoc chua chu, so va cac ky tu -, ., _';
  }
  return '';
};

export const validatePassword = (password) => {
  if (!password || password.trim() === '') {
    return 'Mat khau khong duoc de trong';
  }
  if (password.length < 6 || password.length > 100) {
    return 'Mat khau phai co co tu 6-100 ky tu';
  }
  if (!/(?=.*[A-Za-z])(?=.*\d)/.test(password)) {
    return 'Mat khau phai chua ca chu va so';
  }
  return '';
};
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{Coverage.png}
        \caption{Độ phủ của module sau khi Refactor}
        \label{fig:fe-tdd-refactor}
    \end{figure}

    \subsubsection{2.1.2. Phát triển unit tests cho validation module của Product}

    Tương tự như Login, module Product cũng được phát triển theo quy trình TDD. Do số lượng dữ liệu nhiều (Name, Price, Quantity, Description, Category), chỉ tập trung kiểm thử các giá trị biến (Boundary Testing) và các nghiệp vụ ràng buộc quan trọng.

    \textbf{Buoc 1: Red (Viet Test Case)} \\
    Viết kịch bản kiểm thử cho các trường hợp: Tên rỗng, Giá/Số lượng âm hoặc vượt qua giới hạn cho phép.

    \begin{lstlisting}[language=Java, caption={Product Validation Test Script (Red Phase)}]
import { validateProduct } from '../../utils/productValidation';

describe('Product Validation Tests', () => {
  describe('validateProduct', () => {
    test('TC1: Product name rong hoac qua ngan', () => {
      const productEmpty = { name: '', price: 1000, quantity: 10, category_id: '1' };
      expect(validateProduct(productEmpty).name).toBe('Ten san pham khong duoc de trong');

      const productShort = { ...productEmpty, name: 'ab' };
      expect(validateProduct(productShort).name).toBe('Ten san pham phai co it nhat 3 ky tu');
    });

    test('TC2: Price va Quantity khong hop le (Am hoac qua lon)', () => {
      const productNegPrice = { name: 'Laptop', price: -1000, quantity: 10, category_id: '1' };
      expect(validateProduct(productNegPrice).price).toBe('Gia san pham phai lon hon 0');

      const productHugeQty = { name: 'Laptop', price: 1000, quantity: 10001, category_id: '1' };
      expect(validateProduct(productHugeQty).quantity).toBe('So luong khong duoc qua 10000');
    });

    test('TC3: Category rong', () => {
      const product = { name: 'Laptop', price: 1000, quantity: 10, category_id: '' };
      expect(validateProduct(product).category).toBe('Vui long chon danh muc');
    });

    test('TC4: Product hop le', () => {
      const product = {
        name: 'Laptop Dell',
        price: 15000000,
        quantity: 10,
        category_id: '1',
        description: 'May tinh xach tay'
      };
      const errors = validateProduct(product);
      expect(Object.keys(errors).length).toBe(0); // Khong co loi
    });
  });
});
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\linewidth]{ProductValidation-Red.png}
        \caption{Kết quả test product thất bại (Red Phase)}
        \label{fig:prod-tdd-red}
    \end{figure}

    \textbf{Buoc 2: Green (Viết Code Logic)} \\
    Xây dựng hàm \texttt{validateProduct} để xử lý các logic trên. Sử dụng đối tượng \texttt{errors} để tập hợp các lỗi trả về.

    \begin{lstlisting}[language=Java, caption={Product Implementation (Green Phase)}]
export const validateProduct = (data) => {
  const errors = {};

  if (!data.name || !data.name.trim()) {
    errors.name = 'Ten san pham khong duoc de trong';
  } else if (data.name.length < 3) {
    errors.name = 'Ten san pham phai co it nhat 3 ky tu';
  } else if (data.name.length > 100) {
    errors.name = 'Ten san pham khong duoc qua 100 ky tu';
  }

  const price = Number(data.price);
  if (price <= 0) {
    errors.price = 'Gia san pham phai lon hon 0';
  } else if (price > 100000000) {
    errors.price = 'Gia san pham khong duoc qua 100 trieu';
  }

  const qty = Number(data.quantity);
  if (qty < 0) {
    errors.quantity = 'So luong phai >= 0';
  } else if (qty > 10000) {
    errors.quantity = 'So luong khong duoc qua 10000';
  }

  if (!data.category_id) {
    errors.category = 'Vui long chon danh muc';
  }

  return errors;
};
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\linewidth]{ProductValidation-Green.png}
        \caption{Kết quả test Product thành công (Green Phase)}
        \label{fig:prod-tdd-green}
    \end{figure}

    \textbf{Bước 3: Refactor (Tối ưu)} \\
    Do logic validation product khá nhiều điều kiện if-else, trong bước Refactor, nhóm tiến hành kiểm tra lại coverage để đảm bảo các nhánh (branch) điều kiện như giá min/max, số lượng min/max đều được bao phủ.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{Coverage.png}
        \caption{Độ phủ mã nguồn cua module Product Validation đạt mức cao}
        \label{fig:prod-tdd-refactor}
    \end{figure}
    \subsection{2.2. Backend Unit Tests (JUnit 5)}
    Thay vì sử dụng Mockito, nhóm xây dựng các lớp **FakeDependency** để giả lập hành vi của Database thật. Điều này giúp Unit Test hoàn toàn độc lập với Database.

    \subsubsection{2.2.1. Login Service Tests}
    Kiểm thử \texttt{AuthService} sử dụng \texttt{FakeUserRepository, FakePasswordEncoder, FakeJwtService, FakeAuthenticationManager, Fake UserDetailsService}.

    \begin{lstlisting}[language=Java, caption={AuthService Test voi Fake Dependency}]
@DisplayName("Login Service Unit tests")
public class AuthServiceTest {
    private AuthService authService;

    private UserRepository fakeRepository;
    private PasswordEncoder fakeEncoder;
    private JwtService fakeJwtService;
    private AuthenticationManager fakeAuthManager;
    private UserDetailsService fakeUserDetailsService;

    @BeforeEach
    void setUp(){
        fakeEncoder = new PasswordEncoder() {
            @Override
            public String encode(CharSequence rawPassword) {
                return rawPassword.toString() + "_encoded";
            }

            @Override
            public boolean matches(CharSequence rawPassword, String encodedPassword) {
                return ((rawPassword.toString() + "_encoded").equals(encodedPassword));
            }
        };
        fakeAuthManager = new AuthenticationManager() {
            @Override
            public Authentication authenticate(Authentication authentication) throws AuthenticationException {
                return new UsernamePasswordAuthenticationToken(authentication.getPrincipal(), authentication.getCredentials());
            }
        };
        fakeJwtService = new JwtService() {
            @Override
            public String generateToken(UserDetails userDetails) {
                return "fake-jwt-token-123456";
            }
        };
        fakeUserDetailsService = new UserDetailsService() {
            @Override
            public UserDetails loadUserByUsername(String username) {
                return org.springframework.security.core.userdetails.User
                        .withUsername(username).password("password").authorities("USER").build();
            }
        };
        fakeRepository = new BaseFakeUserRepository() {
            @Override
            public Optional<User> findByUsername(String username) {
                if ("admin".equals(username)) {
                    User u = new User();
                    u.setUsername("admin");
                    u.setPassword("123456_encoded");
                    return Optional.of(u);
                }
                return Optional.empty();
            }
        };
        authService = new AuthService(fakeEncoder, fakeRepository, fakeJwtService, fakeAuthManager, fakeUserDetailsService);
    }
    @Test
    @DisplayName("TC1: Login thanh cong voi credentials hop le")
    void testLoginSuccess(){
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO("admin", "123456");
        LoginResponseDTO loginResponseDTO = authService.login(loginRequestDTO);
        assertNotNull(loginResponseDTO.getAccessToken());
        assertEquals("Bearer Token", loginResponseDTO.getHeader());
    }

    @Test
    @DisplayName("TC2: Login that bai voi username khong ton tai")
    void testLoginFailure(){
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO("notFoundUser", "123456");
        UsernameNotFoundException ex = assertThrows(
                UsernameNotFoundException.class,
                () -> authService.login(loginRequestDTO)
        );
        assertEquals("Tai khoan khong ton tai", ex.getMessage());
    }
    @Test
    @DisplayName("TC3: Login that bai voi password sai")
    void testLoginFailure_WrongPassword(){
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO("admin", "wrongPassword");
        BadCredentialsException ex = assertThrows(BadCredentialsException.class,
                () -> authService.login(loginRequestDTO));
        assertEquals("Mat khau khong dung", ex.getMessage());
    }
}
    \end{lstlisting}

    \subsubsection{2.2.2. Product Service Tests}
    Kiểm thử \texttt{ProductService} sử dụng \texttt{FakeProductRepository, FakeCategoryResponsitory, Fake ProductMapper} và dùng 2 danh sách Category và Product để thay thế `database` để kiểm tra logic CRUD.

    \begin{lstlisting}[language=Java, caption={ProductService Test voi Fake Dependency}]
@DisplayName("Product Service Unit tests")
public class ProductServiceTest {
    private ProductService productService;

    private ProductRepository productRepository;
    private CategoryRepository categoryRepository;
    private ProductMapper productMapper;
    private List<Product> dbProducts;
    private List<Category> dbCategories;


    @BeforeEach
    void setUp() {
        dbCategories = new ArrayList<>();
        dbCategories.add(Category.builder().id(1L).name("Laptop").build());
        dbCategories.add(Category.builder().id(2L).name("Smartphone").build());
        dbProducts = new ArrayList<>();
        dbProducts.add(Product.builder()
                .id(1L)
                .name("Dell Xenos 3000")
                .price(BigDecimal.valueOf(15000000))
                .quantity(10)
                .description("Dell la laptop")
                .category(dbCategories.get(0))
                .build()
        );

        dbProducts.add(Product.builder()
                .id(2L)
                .name("Iphone 15")
                .price(BigDecimal.valueOf(20000000))
                .quantity(5)
                .description("Iphone la mobile")
                .category(dbCategories.get(1))
                .build()
        );

        productRepository = new BaseFakeProductRepository() {
            @Override
            public <S extends Product> S save(S entity) {
                if (entity.getId() == null) {
                    entity.setId(dbProducts.size() + 1L);
                    dbProducts.add(entity);
                } else {
                    for (int i = 0; i < dbProducts.size(); i++) {
                        if (dbProducts.get(i).getId().equals(entity.getId())) {
                            dbProducts.set(i, entity);
                            break;
                        }
                    }
                }
                return entity;
            }

            @Override
            public Optional<Product> findById(Long id) {
                return dbProducts.stream().filter(p -> p.getId().equals(id)).findFirst();
            }

            @Override
            public Page<Product> findAll(Pageable pageable) {
                int start = pageable.getPageNumber() * pageable.getPageSize();
                List<Product> list;
                if (start >= dbProducts.size()) list = new ArrayList<>();
                else {
                    int end = Math.min(start + pageable.getPageSize(), dbProducts.size());
                    list = dbProducts.subList(start, end);
                }
                return new PageImpl<>(list, pageable, dbProducts.size());
            }
            @Override
            public List<Product> findAll() {
                return dbProducts;
            }

            @Override
            public void delete(Product entity) {
                dbProducts.removeIf(p -> p.getId().equals(entity.getId()));
            }
        };
        categoryRepository = new BaseFakeCategoryRepository() {
            @Override
            public Optional<Category> findById(Long id) {
                return dbCategories.stream().filter(c -> c.getId().equals(id)).findFirst();
            }
        };
        productMapper = new ProductMapper() {
            @Override
            public ProductResponseDTO toProductResponseDTO(Product product) {
                return new ProductResponseDTO(
                        product.getId(),
                        product.getName(),
                        product.getPrice(),
                        product.getQuantity(),
                        product.getDescription(),
                        product.getCategory()
                );
            }
        };
        productService = new ProductService(productRepository, categoryRepository, productMapper);
    }

    @Test
    @DisplayName("TC1: Tao san pham moi thanh cong")
    void testCreateProduct() {
        ProductRequestDTO productRequestDTO = new ProductRequestDTO(
                "Asus Xenos 3000",
                BigDecimal.valueOf(15000000),
                10,
                "Asus la Laptop",
                1L
        );
        ProductResponseDTO result = productService.createProduct(productRequestDTO);
        assertNotNull(result);
        assertEquals(3L, result.getId());
        assertEquals("Asus Xenos 3000", result.getProductName());
        assertEquals(BigDecimal.valueOf(15000000), result.getPrice());
        assertEquals(10, result.getQuantity());
        assertEquals("Asus la Laptop", result.getDescription());
    }

    @Test
    @DisplayName("TC2: Cap nhat thong tin san pham thanh cong")
    void testUpdateProduct() {
        ProductRequestDTO productRequestDTO = new ProductRequestDTO(
                "Dell Xenos 3000",
                BigDecimal.valueOf(20000000),
                30,
                "Dell la laptop",
                1L
        );
        ProductResponseDTO result = productService.updateProduct(1L, productRequestDTO);
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("Dell Xenos 3000", result.getProductName());
        assertEquals(BigDecimal.valueOf(20000000), result.getPrice());
        assertEquals(30, result.getQuantity());
        assertEquals("Dell la laptop", result.getDescription());
    }

    @Test
    @DisplayName("TC3: Xoa san pham thanh cong")
    void testDeleteProduct() {
        ProductResponseDTO result = productService.deleteProduct(1L);
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("Dell Xenos 3000", result.getProductName());
        assertEquals(BigDecimal.valueOf(15000000), result.getPrice());
        assertEquals(10, result.getQuantity());
        assertEquals("Dell la laptop", result.getDescription());
    }

    @Test
    @DisplayName("TC4: Lay thong tin san pham thanh cong")
    void testGetProduct() {
        ProductResponseDTO result = productService.getProduct(1L);
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("Dell Xenos 3000", result.getProductName());
        assertEquals(BigDecimal.valueOf(15000000), result.getPrice());
        assertEquals(10, result.getQuantity());
        assertEquals("Dell la laptop", result.getDescription());
    }

    @Test
    @DisplayName("TC5: Lay danh sach san pham thanh cong")
    void testGetAllProduct() {
        assertEquals(2, dbProducts.size());

        Page<ProductResponseDTO> pageResult = productService.getAllProduct(0, 10);

        assertNotNull(pageResult);
        assertEquals(2, pageResult.getTotalElements());
        assertEquals(1, pageResult.getTotalPages());
        assertEquals(2, pageResult.getContent().size());
        assertEquals("Dell Xenos 3000", pageResult.getContent().get(0).getProductName());

        Page<ProductResponseDTO> pageSmall = productService.getAllProduct(0, 1);
        assertEquals(2, pageSmall.getTotalElements());
        assertEquals(2, pageSmall.getTotalPages());
        assertEquals(1, pageSmall.getContent().size());
        assertEquals("Dell Xenos 3000", pageSmall.getContent().get(0).getProductName());

        Page<ProductResponseDTO> pageNext = productService.getAllProduct(1, 1);
        assertEquals(1, pageNext.getContent().size());
        assertEquals("Iphone 15", pageNext.getContent().get(0).getProductName());
    }
}

    \end{lstlisting}

    \subsection{2.3. Báo cáo độ bao phủ (Test Coverage)}
    Theo yêu cầu của môn học, nhóm đảm bảo độ bao phủ code đạt tiêu chuẩn.
    \begin{itemize}
        \item \textbf{Frontend Coverage:} Đạt \textbf{100\%} cho module Login và đạt \textbf{92\%} cho module Product (Yêu cầu $\ge$ 90\% cho module validation).
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{Coverage.png}
            \caption{LoginValidation va ProductValidation Coverage}
        \end{figure}
        \item \textbf{Backend Coverage:} Đạt \textbf{100\%} (Yêu cầu $\ge$ 85\% cho AuthService và ProductService).
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{BackendServiceCoverage.png}
            \caption{AuthService va ProductService Coverage}
        \end{figure}
    \end{itemize}

% Bạn nên chèn hình ảnh coverage report từ Jest/JaCoCo vào đây nếu có
% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.8\textwidth]{coverage_report.png}
%     \caption{Báo cáo độ bao phủ Code Coverage}
% \end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage
    \section{CÂU 3: INTEGRATION TESTING}

% ===============================================================
    \subsection{3.1 Login - Integration Testing}
    \subsubsection{3.1.1 Test tích hợp Login component với API service}

% ---------------------------------------------------------------
    \subsubsubsection{a) Test rendering \& user interactions}

    \begin{itemize}
        \item Kiểm tra hiển thị đầy đủ giao diện và nhập liệu.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Hiển thị đúng giao diện và nhập liệu}]
test("Render UI and allow user input", () => {
  render(
    <MemoryRouter>
      <Login />
    </MemoryRouter>
  );

  const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
  const passwordInput = screen.getByLabelText(/Mat khau/i);

  // Kiem tra render
  expect(usernameInput).toBeInTheDocument();
  expect(passwordInput).toBeInTheDocument();

  // Kiem tra nhap lieu
  fireEvent.change(usernameInput, { target: { value: "validuser" } });
  fireEvent.change(passwordInput, { target: { value: "valid123" } });

  expect(usernameInput.value).toBe("validuser");
  expect(passwordInput.value).toBe("valid123");
});
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{b) Test form submission \& API calls}

    \begin{itemize}
        \item Kiểm tra API không được gọi khi input invalid.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Không gọi API nếu submit form không hợp lệ}]
test("Not calling API if submit invalid form", async () => {
  render(
    <MemoryRouter>
      <Login />
    </MemoryRouter>
  );

  const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
  const passwordInput = screen.getByLabelText(/Mat khau/i);
  const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

  fireEvent.change(usernameInput, { target: { value: "invalid@" } });
  fireEvent.change(passwordInput, { target: { value: "invalid" } });
  fireEvent.click(submitButton);

  expect(submitButton).toBeDisabled();

  await waitFor(() => {
    expect(authService.logIn).not.toHaveBeenCalled();
  });
});
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra API được gọi khi input hợp lệ.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Gọi API khi submit form hợp lệ}]
test("Verify API is called when submit valid form", async () => {
  render(
    <MemoryRouter>
      <Login />
    </MemoryRouter>
  );

  const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
  const passwordInput = screen.getByLabelText(/Mat khau/i);
  const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

  fireEvent.change(usernameInput, { target: { value: "validuser" } });
  fireEvent.change(passwordInput, { target: { value: "valid123" } });
  fireEvent.click(submitButton);

  expect(submitButton).toBeDisabled();

  await waitFor(() => {
    expect(authService.logIn).toHaveBeenCalledTimes(1);
    expect(authService.logIn).toHaveBeenCalledWith("validuser", "valid123");
  });
});
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{c) Test Error Handling \& Success Messages}

    \begin{itemize}
        \item Kiểm tra trường hợp API trả về thành công.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Hiển thị thông báo thành công nếu API trả về thành công}]
beforeEach(() => {
  useAuthStore.getState().clearState();
  removeJWTfromCookie();
  jest.clearAllMocks();
});

test("API response success -> set Token to state -> navigate", async () => {
  authService.logIn.mockResolvedValue({
    status: 200,
    accessToken: "mockAccessToken",
  });

  render(
    <MemoryRouter>
      <Login />
    </MemoryRouter>
  );

  const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
  const passwordInput = screen.getByLabelText(/Mat khau/i);
  const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

  fireEvent.change(usernameInput, { target: { value: "correctUser" } });
  fireEvent.change(passwordInput, { target: { value: "correctPassword1" } });

  fireEvent.click(submitButton);
  expect(submitButton).toBeDisabled();

  await waitFor(() => {
    expect(authService.logIn).toHaveBeenCalledTimes(1);
    expect(authService.logIn).toHaveBeenCalledWith("correctUser", "correctPassword1");

    expect(setJWTtoCookie).toHaveBeenCalledWith("mockAccessToken");
    expect(useAuthStore.getState().accessToken).toBe("mockAccessToken");
    expect(useAuthStore.getState().loading).toBe(false);
    expect(mockNavigate).toHaveBeenCalledWith("/admin/products");
  });

  await waitFor(() => {
    expect(toast.success).toHaveBeenCalledWith(
      "Dang nhap thanh cong",
      expect.objectContaining({
        description: expect.any(Object),
      })
    );
  });
});
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra trường hợp API trả về lỗi.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Hiển thị thông báo lỗi nếu API trả lỗi}]
beforeEach(() => {
  useAuthStore.getState().clearState();
  removeJWTfromCookie();
  jest.clearAllMocks();
});

test("API response FAIL -> Show error notification -> not navigate", async () => {
  authService.logIn.mockRejectedValue(new Error("API Login Error"));

  render(
    <MemoryRouter>
      <Login />
    </MemoryRouter>
  );

  const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
  const passwordInput = screen.getByLabelText(/Mat khau/i);
  const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

  fireEvent.change(usernameInput, { target: { value: "username" } });
  fireEvent.change(passwordInput, { target: { value: "password123" } });

  fireEvent.click(submitButton);
  expect(submitButton).toBeDisabled();

  await waitFor(() => {
    expect(authService.logIn).toHaveBeenCalledTimes(1);
    expect(authService.logIn).toHaveBeenCalledWith("username", "password123");
    expect(toast.error).toHaveBeenCalled();
    expect(mockNavigate).not.toHaveBeenCalled();
  });
});
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.95\linewidth]{LoginIntegrationFE.jpg}
        \caption{Kết quả chạy toàn bộ bài kiểm thử Login Integration Test}
        \label{fig:login_integration_result}
    \end{figure}
% ===============================================================
    \subsubsection{3.1.2 Test API endpoints của Login với MockMvc}

% ---------------------------------------------------------------
    \subsubsubsection{a, b) Test POST /api/auth/login endpoint \& Test response structure và status codes}

    \begin{itemize}
        \item Đăng nhập thành công và response structure.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={POST /api/auth/login endpoint - SUCCESS}]
@Test
@DisplayName("POST /api/auth/login endpoint - SUCCESS")
void testLoginSuccess() throws Exception {
    LoginRequestDTO loginRequestDTO = new LoginRequestDTO(
            "admin123",
            "admin123"
    );
    LoginResponseDTO mockResponse = new LoginResponseDTO(
            "fake_jwt_token"
    );
    when(authService.login(any(LoginRequestDTO.class)))
            .thenReturn(mockResponse);

    when(jwtService.validateToken(any(), any())).thenReturn(true);
    when(jwtService.getUsernameFromToken(any())).thenReturn("admin123");
    when(authService.login(any(LoginRequestDTO.class))).thenReturn(mockResponse);
    mockMvc.perform(post("/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(loginRequestDTO)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.accessToken").exists())
            .andExpect(jsonPath("$.user.password").doesNotExist())
    ;
}
    \end{lstlisting}

    \begin{itemize}
        \item Đăng nhập thất bại - Username không tồn tại.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={POST /api/auth/login endpoint - FAILED - Username không tồn tại}]
@Test
@DisplayName("POST /api/auth/login endpoint - FAILED - Username khong ton tai")
void testLoginFailed_UsernameNotFound() throws Exception {
    LoginRequestDTO loginRequestDTO = new LoginRequestDTO(
            "unknownUser",
            "admin123"
    );
    when(authService.login(any(LoginRequestDTO.class)))
            .thenThrow(new UsernameNotFoundException("Tai khoan khong ton tai"));
    mockMvc.perform(post("/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(loginRequestDTO)))
            .andExpect(jsonPath("$.message").value("Tai khoan khong ton tai"))
            .andExpect(status().isNotFound());

}
    \end{lstlisting}

    \begin{itemize}
        \item Đăng nhập thất bại - Sai Password.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={POST /api/auth/login endpoint - FAILED - Sai Password}]
@Test
@DisplayName("POST /api/auth/login endpoint - FAILED -Sai Password")
void testLoginFailed_PasswordIncorrect() throws Exception {
    LoginRequestDTO loginRequestDTO = new LoginRequestDTO(
            "admin123",
            "wrongPassword123"
    );
    when(authService.login(any(LoginRequestDTO.class)))
            .thenThrow(new BadCredentialsException("Mat khau khong dung"));
    mockMvc.perform(post("/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(loginRequestDTO)))
            .andExpect(jsonPath("$.message").value("Mat khau khong dung"))
            .andExpect(status().isUnauthorized());
}
    \end{lstlisting}

    \begin{itemize}
        \item Đăng nhập thất bại - Password sai định dạng.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={POST /api/auth/login endpoint - FAILED - Password sai định dạng}]
@Test
@DisplayName("POST /api/auth/login endpoint - FAILED - Password sai dinh dang")
void testLoginFailed_InvalidPassword() throws Exception {
    LoginRequestDTO loginRequestDTO = new LoginRequestDTO(
            "admin123",
            "221123"
    );
    mockMvc.perform(post("/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(loginRequestDTO)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.messages.password").value(
                    "Mat khau phai co ca chu va so"
            ));
}
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{c) Test CORS và headers}

    \begin{itemize}
        \item Kiểm tra CORS và headers.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Kiểm tra CORS headers cho POST request}]
@Test
void testCORSHeaders_POST() throws Exception {
    mockMvc.perform(post("/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .header("Origin", "http://localhost:3000")
                    .header("Access-Control-Request-Method", "POST")
                    .header("Access-Control-Request-Headers", "content-type")
                    .content(objectMapper.writeValueAsString(new LoginRequestDTO("admin123", "admin123"))))
            .andExpect(status().isOk());

}
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.95\linewidth]{LoginApiIntegration.jpg}
        \caption{Kết quả chạy toàn bộ bài kiểm thử Login API Integration Test}
        \label{fig:login_api_integration_result}
    \end{figure}


% ===============================================================
    \newpage
    \subsection{3.2 Product - Integration Testing}
    \subsubsection{3.2.1 Test tích hợp Product components với API service}

% ---------------------------------------------------------------
    \subsubsubsection{a) Test ProductTable component với API}

    \begin{itemize}
        \item Fetch thành công và hiển thị danh sách sản phẩm.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Fetch thành công và hiển thị danh sách sản phẩm}]
test("Fetch thanh cong va hien thi danh sach san pham", async () => {
  render(<ProductTable onEdit={mockOnEdit} onDelete={mockOnDelete} />);

  //Loading state ban dau
  expect(screen.getByText("Dang tai...")).toBeInTheDocument();

  await waitFor(() => {
    //Check service
    expect(productService.getAllProducts).toHaveBeenCalledTimes(1);

    //Check store
    const { products } = useProductStore.getState();
    expect(products).toHaveLength(mockProducts.length);
    expect(products[0].productName).toBe("iPhone 14 Pro Max");

    //Check UI render products
    mockProducts.forEach((p) => {
      expect(screen.getByText(p.productName)).toBeInTheDocument();
    });
  });
});
    \end{lstlisting}

    \begin{itemize}
        \item Fetch thất bại và hiển thị lỗi.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Fetch danh sách sản phẩm thất bại và hiển thị lỗi}]
test("Fetch danh sach san pham that bai va hien thi loi", async () => {
  productService.getAllProducts.mockRejectedValue(
    new Error("Network Error")
  );

  render(<ProductTable onEdit={mockOnEdit} onDelete={mockOnDelete} />);

  //Loading state ban dau
  expect(screen.getByText("Dang tai...")).toBeInTheDocument();

  await waitFor(() => {
    expect(toast.error).toHaveBeenCalledWith(
      "Co loi khi lay danh sach san pham"
    );

    const { products } = useProductStore.getState();
    expect(products).toHaveLength(0);

    expect(screen.getByText("Chua co san pham nao")).toBeInTheDocument();
  });
});
    \end{lstlisting}
% ---------------------------------------------------------------
    \subsubsubsection{b) Test ProductForm component (create/edit)}

    \begin{itemize}
        \item Kiểm tra hiển thị form thêm sản phẩm.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Hiển thị form thêm sản phẩm}]
test("Hien thi form them san pham", async () => {
  render(
    <ProductFormModal
      categories={mockCategories}
      onClose={mockOnClose}
      onSubmit={mockOnSubmit}
    />
  );

  expect(screen.getByText("Them san pham moi")).toBeInTheDocument();
  expect(screen.getByTestId("product-name")).toBeInTheDocument();
  expect(screen.getByTestId("product-price")).toBeInTheDocument();
  expect(screen.getByTestId("product-quantity")).toBeInTheDocument();
  expect(screen.getByTestId("product-quantity")).toHaveValue(1);
  expect(screen.getByTestId("product-category")).toBeInTheDocument();
  expect(screen.getByTestId("product-description")).toBeInTheDocument();

  // Check categories trong dropdown
  await waitFor(() => {
    mockCategories.forEach((cat) => {
      expect(screen.getByText(cat.name)).toBeInTheDocument();
    });
  });

  expect(screen.getByTestId("submit-btn")).toHaveTextContent("Them moi");
});
    \end{lstlisting}

    \begin{itemize}
        \item Hiển thị form chỉnh sửa với data pre-filled.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Hiển thị form chỉnh sửa với data pre-filled}]
test("Hien thi form chinh sua voi data pre-filled", async () => {
  getCategoryIdFromName.mockReturnValue(1);

  render(
    <ProductFormModal
      categories={mockCategories}
      product={mockProducts[0]}
      onClose={mockOnClose}
      onSubmit={mockOnSubmit}
    />
  );

  expect(screen.getByText("Chinh sua san pham")).toBeInTheDocument();
  expect(screen.getByTestId("submit-btn")).toHaveTextContent("Cap nhat");

  // Wait for useEffect
  await waitFor(
    () => {
      expect(
        screen.getByDisplayValue("iPhone 14 Pro Max")
      ).toBeInTheDocument();
      expect(screen.getByDisplayValue(24000000)).toBeInTheDocument();
      expect(screen.getByDisplayValue(10)).toBeInTheDocument();
      expect(
        screen.getByDisplayValue("iPhone 14 Pro Max 256GB")
      ).toBeInTheDocument();

      // Check category select
      const categorySelect = screen.getByTestId("product-category");
      expect(categorySelect).toHaveValue("1");
    },
    { timeout: 2000 }
  );

  //Check helper function
  expect(getCategoryIdFromName).toHaveBeenCalledWith(
    "iPhone",
    mockCategories
  );
  expect(getCategoryIdFromName).toHaveBeenCalledTimes(1);
});
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra tạo sản phẩm mới thành công.
    \end{itemize}
    \begin{lstlisting}[language=Java, caption={Tạo sản phẩm mới thành công}]
test("Tao san pham moi thanh cong", async () => {
  const newProduct = {
    id: 3,
    productName: "iPhone 15 Pro",
    price: 25000000,
    quantity: 15,
    description: "iPhone 15 Pro 256GB",
    category: { id: 1, name: "iPhone" },
  };
  productService.addProduct.mockResolvedValue(newProduct);

  render(
    <ProductFormModal categories={mockCategories} onClose={mockOnClose} />
  );

  fireEvent.change(screen.getByTestId("product-name"), {
    target: { value: "iPhone 15 Pro" },
  });
  fireEvent.change(screen.getByTestId("product-price"), {
    target: { value: "25000000" },
  });
  fireEvent.change(screen.getByTestId("product-quantity"), {
    target: { value: "15" },
  });
  fireEvent.change(screen.getByTestId("product-category"), {
    target: { value: "1" },
  });
  fireEvent.change(screen.getByTestId("product-description"), {
    target: { value: "iPhone 15 Pro 256GB" },
  });

  fireEvent.click(screen.getByTestId("submit-btn"));

  await waitFor(() => {
    // Check if service is called
    expect(productService.addProduct).toHaveBeenCalledWith({
      productName: "iPhone 15 Pro",
      price: 25000000,
      quantity: 15,
      category_id: "1",
      description: "iPhone 15 Pro 256GB",
    });

    expect(toast.success).toHaveBeenCalledWith("Them moi thanh cong", {
      description: expect.anything(),
    });
  });

  // Check if store update
  await waitFor(() => {
    const { products } = useProductStore.getState();
    expect(products).toContainEqual(newProduct);
  });
});
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra cập nhật sản phẩm thành công.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Cập nhật sản phẩm thành công}]
test("Cap nhat san pham thanh cong", async () => {
  const updatedProduct = {
    id: 1,
    productName: "iPhone 15 Pro",
    price: 25000000,
    quantity: 15,
    description: "iPhone 15 Pro 256GB",
    category: { id: 1, name: "iPhone" },
  };

  productService.updateProduct.mockResolvedValue(updatedProduct);

  useProductStore.setState((state) => ({
    ...state,
    products: [...mockProducts],
    quantity: mockProducts.length,
  }));

  render(
    <ProductFormModal
      product={mockProducts[0]}
      categories={mockCategories}
      onClose={mockOnClose}
    />
  );

  fireEvent.change(screen.getByTestId("product-name"), {
    target: { value: "iPhone 15 Pro" },
  });
  fireEvent.change(screen.getByTestId("product-price"), {
    target: { value: "25000000" },
  });
  fireEvent.change(screen.getByTestId("product-quantity"), {
    target: { value: "15" },
  });
  fireEvent.change(screen.getByTestId("product-category"), {
    target: { value: "1" },
  });
  fireEvent.change(screen.getByTestId("product-description"), {
    target: { value: "iPhone 15 Pro 256GB" },
  });

  fireEvent.click(screen.getByTestId("submit-btn"));

  await waitFor(() => {
    expect(productService.updateProduct).toHaveBeenCalledWith(
      mockProducts[0].id,
      {
        productName: "iPhone 15 Pro",
        price: 25000000,
        quantity: 15,
        category_id: "1",
        description: "iPhone 15 Pro 256GB",
      }
    );

    expect(toast.success).toHaveBeenCalledWith("Cap nhat thanh cong", {
      description: expect.anything(),
    });
  });

  await waitFor(() => {
    const { products } = useProductStore.getState();
    const updatedProductInStore = products.find(
      (p) => p.id === mockProducts[0].id
    );
    expect(updatedProductInStore).toEqual(updatedProduct);
    expect(products).toHaveLength(mockProducts.length);
  });
});
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{c) Test hiển thị chi tiết sản phẩm trong bảng}

    \begin{itemize}
        \item Kiểm tra hiển thị đầy đủ thông tin sản phẩm.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={Hiển thị đầy đủ thông tin chi tiết sản phẩm trong table}]
test("Hien thi day du thong tin chi tiet san pham trong table", async () => {
  render(<ProductTable onEdit={mockOnEdit} onDelete={mockOnDelete} />);

  await waitFor(() => {
    expect(screen.getByText("1")).toBeInTheDocument();
    expect(screen.getByText("2")).toBeInTheDocument();
    expect(screen.getByText("iPhone 14 Pro Max")).toBeInTheDocument();
    expect(screen.getByText("Samsung Galaxy S23")).toBeInTheDocument();
    expect(screen.getByText("iPhone")).toBeInTheDocument();
    expect(screen.getByText("Samsung")).toBeInTheDocument();
    expect(screen.getByText("10")).toBeInTheDocument();
    expect(screen.getByText("5")).toBeInTheDocument();
    expect(screen.getByText("iPhone 14 Pro Max 256GB")).toBeInTheDocument();
    expect(
      screen.getByText("Samsung Galaxy S23 Ultra")
    ).toBeInTheDocument();
  });

  expect(formatVND).toHaveBeenCalledWith(24000000);
  expect(formatVND).toHaveBeenCalledWith(18000000);
});
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.95\linewidth]{ProductIntegrationFE.jpg}
        \caption{Kết quả chạy toàn bộ bài kiểm thử Product Integration Test}
        \label{fig:product_integration_result}
    \end{figure}
    \subsubsection{3.2.2 Test các API endpoints của Product}
    \subsubsubsection{a) Test CREATE - POST /api/products}

    \begin{itemize}
        \item Kiểm tra tạo sản phẩm mới thành công.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={POST /api/products - SUCCESS - Tạo sản phẩm mới thành công}]
@Test
@DisplayName("POST /api/products - SUCCESS - Tao san pham moi thanh cong")
void createProductSuccess() throws Exception {

    ProductRequestDTO productRequestDTO = new ProductRequestDTO(
            "Laptop DELL XPS",
            new BigDecimal("24000000"),
            10,
            "High-end Laptop",
            1L
    );

    ProductResponseDTO mockResponse = new ProductResponseDTO(
            4L,
            "Laptop DELL XPS",
            new BigDecimal("24000000"),
            10,
            "High-end Laptop",
            new Category("Laptop")
    );

    when(categoryService.existsById(1L)).thenReturn(true);
    when(productService.createProduct(any(ProductRequestDTO.class))).thenReturn(mockResponse);

    mockMvc.perform(post("/products")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(productRequestDTO)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(4L))
            .andExpect(jsonPath("$.productName").value("Laptop DELL XPS"));
}
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra tạo sản phẩm thất bại - Category không tồn tại.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={POST /api/products - FAILED - Category không tồn tại}]
@Test
@DisplayName("POST /api/products - FAILED - Category khong ton tai")
void createProductFail_CategoryNotFound() throws Exception {
    ProductRequestDTO request = new ProductRequestDTO(
            "Laptop DELL XPS",
            new BigDecimal("24000000"),
            10,
            "High-end Laptop",
            99L
    );

    when(categoryService.existsById(99L)).thenReturn(false);
    when(productService.createProduct(any()))
            .thenThrow(new RuntimeException("Category khong ton tai"));

    mockMvc.perform(post("/products")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.message").value("Category khong ton tai"));
}
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{b) Test GET ALL PRODUCTS - GET /api/products}

    \begin{itemize}
        \item Kiểm tra lấy danh sách tất cả sản phẩm thành công.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={GET /api/products - SUCCESS - Lấy danh sách tất cả sản phẩm thành công}]
@Test
@DisplayName("GET /api/products - SUCCESS - Lay danh sach tat ca san pham thanh cong")
void getAllProducts() throws Exception {

    List<ProductResponseDTO> mockList = Arrays.asList(
            new ProductResponseDTO(1L, "iPhone", new BigDecimal("20000000"), 5, "Apple phone", new Category("Phone")),
            new ProductResponseDTO(2L, "MacBook", new BigDecimal("30000000"), 3, "Apple laptop", new Category("Laptop"))
    );

    when(productService.getAllProduct()).thenReturn(mockList);

    mockMvc.perform(get("/products"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.size()").value(2))
            .andExpect(jsonPath("$[0].productName").value("iPhone"))
            .andExpect(jsonPath("$[1].productName").value("MacBook"));
}
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{c) Test GET PRODUCT - GET /api/products/\{id\}}

    \begin{itemize}
        \item Kiểm tra lấy sản phẩm theo ID thành công.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={GET /api/products/\{id\} - SUCCESS - Lấy sản phẩm theo ID thành công}]
@Test
@DisplayName("GET /api/products/{id} - SUCCESS - Lay san pham theo ID thanh cong")
void getProductById() throws Exception {

    ProductResponseDTO mockProduct = new ProductResponseDTO(
            1L,
            "iPhone",
            new BigDecimal("20000000"),
            5,
            "Apple phone",
            new Category("Phone")
    );

    when(productService.getProduct(1L)).thenReturn(mockProduct);

    mockMvc.perform(get("/products/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(1L))
            .andExpect(jsonPath("$.productName").value("iPhone"));
}
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra lấy sản phẩm thất bại - ID không tồn tại.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={GET /api/products/\{id\} - FAILED - ID không tồn tại}]
@Test
@DisplayName("GET /api/products/{id} - FAILED - id khong ton tai")
void getProductByIdFail_NotFound() throws Exception {

    when(productService.getProduct(99L))
            .thenThrow(new RuntimeException("Product khong ton tai"));

    mockMvc.perform(get("/products/99"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.message").value("Product khong ton tai"));
}
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{d) Test UPDATE PRODUCT - PUT /api/products/\{id\}}

    \begin{itemize}
        \item Kiểm tra cập nhật sản phẩm thành công.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={PUT /api/products/\{id\} - SUCCESS - Cập nhật sản phẩm thành công}]
@Test
@DisplayName("PUT /api/products/{id} - SUCCESS - Cap nhat san pham thanh cong")
void updateProductSuccess() throws Exception {

    ProductRequestDTO updateRequest = new ProductRequestDTO(
            "iPhone 15 Pro",
            new BigDecimal("28000000"),
            7,
            "Latest Apple phone",
            1L
    );

    ProductResponseDTO updatedProduct = new ProductResponseDTO(
            1L,
            "iPhone 15 Pro",
            new BigDecimal("28000000"),
            7,
            "Latest Apple phone",
            new Category("Phone")
    );

    when(categoryService.existsById(1L)).thenReturn(true);
    when(productService.updateProduct(eq(1L), any(ProductRequestDTO.class))).thenReturn(updatedProduct);

    mockMvc.perform(put("/products/1")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(updateRequest)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.productName").value("iPhone 15 Pro"));
}
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra cập nhật sản phẩm thất bại - Category không tồn tại.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={PUT /api/products/\{id\} - FAILED - Category không tồn tại}]
@Test
@DisplayName("PUT /api/products/{id} - FAILED - Category khong ton tai")
void updateProductFail_CategoryNotFound() throws Exception {

    ProductRequestDTO request = new ProductRequestDTO(
            "iPhone 15 Pro",
            new BigDecimal("28000000"),
            7,
            "Latest Apple phone",
            99L
    );

    when(categoryService.existsById(99L)).thenReturn(false);
    when(productService.updateProduct(anyLong(), any(ProductRequestDTO.class)))
            .thenThrow(new RuntimeException("Category khong ton tai"));

    mockMvc.perform(put("/products/1")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.message").value("Category khong ton tai"));
}
    \end{lstlisting}

% ---------------------------------------------------------------
    \subsubsubsection{e) Test DELETE PRODUCT - DELETE /api/products/\{id\}}

    \begin{itemize}
        \item Kiểm tra xóa sản phẩm thành công.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={DELETE /api/products/\{id\} - SUCCESS - Xóa sản phẩm thành công}]
@Test
@DisplayName("DELETE /api/products/{id} - SUCCESS - Xoa san pham thanh cong")
void deleteProduct() throws Exception {

    ProductResponseDTO deletedProduct = new ProductResponseDTO(
            1L,
            "iPhone",
            new BigDecimal("20000000"),
            5,
            "Apple phone",
            new Category("Phone")
    );

    when(productService.deleteProduct(1L)).thenReturn(deletedProduct);

    mockMvc.perform(delete("/products/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(1L))
            .andExpect(jsonPath("$.productName").value("iPhone"))
            .andExpect(jsonPath("$.price").value(20000000))
            .andExpect(jsonPath("$.quantity").value(5))
            .andExpect(jsonPath("$.description").value("Apple phone"))
            .andExpect(jsonPath("$.category.name").value("Phone"));
}
    \end{lstlisting}

    \begin{itemize}
        \item Kiểm tra xóa sản phẩm thất bại - ID không tồn tại.
    \end{itemize}

    \begin{lstlisting}[language=Java, caption={DELETE /api/products/\{id\} - FAILED - ID không tồn tại}]
@Test
@DisplayName("DELETE /api/products/{id} - FAILED - id Khong ton tai")
void deleteProductNotFound() throws Exception {

    when(productService.deleteProduct(99L))
            .thenThrow(new RuntimeException("Product khong ton tai"));

    mockMvc.perform(delete("/products/99"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.message").value("Product khong ton tai"));
}
    \end{lstlisting}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.95\linewidth]{ProductApiIntegration.jpg}
        \caption{Kết quả chạy toàn bộ bài kiểm thử Product API Integration Test}
        \label{fig:product_api_integration_result}
    \end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage
    \section{CÂU 4: MOCK TESTING}

    \subsection{4.1: Login - Mock Testing}

    \subsubsection{4.1.1 Frontend Mocking}

    \textbf{Mục tiêu test:} Mock external dependencies cho Login component nhằm kiểm tra logic và hành vi của component Login trong các tình huống khác nhau mà không phụ thuộc vào backend thực tế.

    \textbf{Các bước thực hiện:}
    \begin{itemize}
        \item Mock authService.loginUser()
        \item Test với mocked successful/failed responses
        \item Verify mock calls
    \end{itemize}

    \textbf{Các test case đã thực hiện:}
    \begin{enumerate}
        \item Login thành công với response hợp lệ
        \item Login thất bại với credentials không đúng (username/password)
        \item Login thất bại với server error
        \item Login thất bại với connection error
    \end{enumerate}

    \textbf{Kết quả test:}
    \begin{center}
        \includegraphics[width=1\textwidth]{Login.mock.test.png}
    \end{center}

    \subsubsection*{Chi tiết các test case:}

    \begin{lstlisting}[language=Java, caption={Login thành công với response hợp lệ}]
    test("Successful response", async () => {
        authService.logIn.mockResolvedValue({
          status: 200,
          accessToken: "mockAccessToken",
        });

        render(
          <MemoryRouter>
            <Login />
          </MemoryRouter>
    );

    const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
    const passwordInput = screen.getByLabelText(/Mat khau/i);
    const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

    fireEvent.change(usernameInput, { target: { value: "correctUser" } });
    fireEvent.change(passwordInput, {
      target: { value: "correctPassword1" },
    });

    fireEvent.click(submitButton);
    expect(submitButton).toBeDisabled();

    await waitFor(() => {
      //Verify mock calls
      expect(authService.logIn).toHaveBeenCalledTimes(1);
      expect(authService.logIn).toHaveBeenCalledWith(
        "correctUser",
        "correctPassword1"
      );

      expect(setJWTtoCookie).toHaveBeenCalledWith("mockAccessToken");
      expect(useAuthStore.getState().accessToken).toBe("mockAccessToken");
      expect(useAuthStore.getState().loading).toBe(false);
      expect(toast.success).toHaveBeenCalledWith(
        "Dang nhap thanh cong ",
        expect.objectContaining({
          description: expect.any(Object),
        })
      );
    });
  });
    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={Login thất bại với username, password sai}]
test.each([
    {
      username: "wrongUsername",
      password: "correctPassword1",
    },
    {
      username: "correctUsername",
      password: "wrongPassword1",
    },
  ])("Failed response - 401 (%o)", async ({ username, password }) => {
    authService.logIn.mockRejectedValue({
      response: { status: 401 },
    });

    render(
      <MemoryRouter>
        <Login />
      </MemoryRouter>
    );

    const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
    const passwordInput = screen.getByLabelText(/Mat khau/i);
    const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

    fireEvent.change(usernameInput, { target: { value: username } });
    fireEvent.change(passwordInput, { target: { value: password } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      //Verify mock calls
      expect(authService.logIn).toHaveBeenCalledTimes(1);
      expect(authService.logIn).toHaveBeenCalledWith(username, password);

      expect(setJWTtoCookie).not.toHaveBeenCalled();
      expect(useAuthStore.getState().accessToken).toBeNull();
      expect(useAuthStore.getState().loading).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Ten dang nhap hoac mat khau khong chinh xac"
      );
    });
  });
    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={Login thất bại khi server error}]
test("Login failed - Server error(500)", async () => {
    authService.logIn.mockRejectedValue({
      response: { status: 500 },
    });

    render(
      <MemoryRouter>
        <Login />
      </MemoryRouter>
    );

    const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
    const passwordInput = screen.getByLabelText(/Mat khau/i);
    const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

    fireEvent.change(usernameInput, { target: { value: "validUser" } });
    fireEvent.change(passwordInput, {
      target: { value: "validPassword1" },
    });
    fireEvent.click(submitButton);

    await waitFor(() => {
      //Verify mock calls
      expect(authService.logIn).toHaveBeenCalledTimes(1);
      expect(authService.logIn).toHaveBeenCalledWith(
        "validUser",
        "validPassword1"
      );

      expect(setJWTtoCookie).not.toHaveBeenCalled();
      expect(useAuthStore.getState().accessToken).toBeNull();
      expect(useAuthStore.getState().loading).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "May chu dang gap su co, vui long thu lai sau!"
      );
    });
  });
    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={Login thất bại khi connection error}]
test("Login failed - Network/Connection Error ", async () => {
    authService.logIn.mockRejectedValue({
      request: {},
    });

    render(
      <MemoryRouter>
        <Login />
      </MemoryRouter>
    );
    const usernameInput = screen.getByLabelText(/Ten dang nhap/i);
    const passwordInput = screen.getByLabelText(/Mat khau/i);
    const submitButton = screen.getByRole("button", { name: /Dang nhap/i });

    fireEvent.change(usernameInput, { target: { value: "validUser" } });
    fireEvent.change(passwordInput, {
      target: { value: "validPassword1" },
    });
    fireEvent.click(submitButton);

    await waitFor(() => {
      //Verify mock calls
      expect(authService.logIn).toHaveBeenCalledTimes(1);
      expect(authService.logIn).toHaveBeenCalledWith(
        "validUser",
        "validPassword1"
      );
      expect(setJWTtoCookie).not.toHaveBeenCalled();
      expect(useAuthStore.getState().accessToken).toBeNull();
      expect(toast.error).toHaveBeenCalledWith(
        "Khong the ket noi den may chu. Vui long kiem tra duong truyen!"
      );
    });
  });
    \end{lstlisting}

    \subsubsection{4.1.2 Backend Mocking}

    \textbf{Mục tiêu test:} Mock dependencies trong Backend tests để kiểm tra logic của controller mà không phụ thuộc vào service thực tế, đảm bảo controller xử lý đúng các request và response.

    \textbf{Các bước thực hiện:}
    \begin{itemize}
        \item Mock AuthService với @MockBean
        \item Test controller với mocked service
        \item Verify mock interactions
    \end{itemize}

    \textbf{Các test case đã thực hiện:}
    \begin{enumerate}
        \item TC001: Login thành công với mocked service
        \item TC002: Login thất bại - username rỗng
        \item TC003: Login thất bại - password rỗng
        \item TC004: Login thất bại - password không có số
        \item TC005: Login thất bại - username quá dài
    \end{enumerate}

    \textbf{Kết quả test:}
    \begin{center}
        \includegraphics[width=1\textwidth]{AuthControllerMockTest.png}
    \end{center}


    \subsubsection*{Chi tiết các test case:}
    \begin{itemize}
        \begin{lstlisting}[language=Java, caption={AuthControllerMockTest.java}]
    @Test
    @DisplayName("TC001: Login success voi mocked service")
    void TC_LOGIN_001() throws Exception {
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO("admin123", "admin123");
        LoginResponseDTO mockResponse = new LoginResponseDTO("fake_jwt_token");

        when(authService.login(any(LoginRequestDTO.class))).thenReturn(mockResponse);

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequestDTO)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").exists());

        verify(authService, times(1)).login(any(LoginRequestDTO.class));
    }
        \end{lstlisting}
        \begin{lstlisting}[language=Java, caption={AuthControllerMockTest.java}]
    @Test
    @DisplayName("TC002: Login Fail - username null")
    void TC_LOGIN_002() throws Exception {
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO("", "Test123");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequestDTO)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.messages.username").exists());

        verify(authService, never()).login(any(LoginRequestDTO.class));
    }

        \end{lstlisting}
        \begin{lstlisting}[language=Java, caption={AuthControllerMockTest.java}]

    @Test
    @DisplayName("TC003: Login Fail - password null")
    void TC_LOGIN_003() throws Exception {
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO("admin123", "");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequestDTO)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.messages.password").exists());

        verify(authService, never()).login(any(LoginRequestDTO.class));
    }
        \end{lstlisting}

        \begin{lstlisting}[language=Java, caption={AuthControllerMockTest.java}]
@Test
    @DisplayName("TC004: Login Fail - password khong co so")
    void TC_LOGIN_004() throws Exception {
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO("testuser", "password");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequestDTO)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.messages.password").exists());

        verify(authService, never()).login(any(LoginRequestDTO.class));
    }
        \end{lstlisting}
        \begin{lstlisting}[language=Java, caption={AuthControllerMockTest.java}]
 @Test
    @DisplayName("TC005: Login that bai - username long > 50")
    void TC_LOGIN_005() throws Exception {
        String longUsername = "a".repeat(51);
        LoginRequestDTO loginRequestDTO = new LoginRequestDTO(longUsername, "password123");

        mockMvc.perform(post("/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequestDTO)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.messages.username").exists());

        verify(authService, never()).login(any(LoginRequestDTO.class));
    }
        \end{lstlisting}
    \end{itemize}

    \subsection{4.2 Product - Mock Testing}
    \subsubsection{4.2.1 Frontend Mocking}
    \textbf{Mục tiêu test:} Mock ProductService trong component tests để kiểm tra các operations CRUD mà không phụ thuộc vào service thực tế.

    \textbf{Các bước thực hiện:}

    \begin{itemize}
        \item Mock CRUD operations của ProductService
        \item Test success và failure scenarios
        \item Verify all mock calls
    \end{itemize}

    \textbf{Các test case đã thực hiện:}
    \begin{enumerate}
        \item Mock: Get products success - Kiểm tra việc lấy danh sách sản phẩm thành công
        \item Mock: Get products failure - Kiểm tra việc lấy danh sách sản phẩm thất bại
        \item Mock: Create product success - Kiểm tra việc tạo sản phẩm mới thành công
        \item Mock: Create product failure - Kiểm tra việc tạo sản phẩm mới thất bại
        \item Mock: Update product success - Kiểm tra việc cập nhật sản phẩm thành công
        \item Mock: Update product failure - Kiểm tra việc cập nhật sản phẩm thất bại
        \item Mock: Delete product success - Kiểm tra việc xóa sản phẩm thành công

    \end{enumerate}

    \textbf{Kết quả test:}
    \begin{center}
        \includegraphics[width=1\textwidth]{Product.mock.test.png}
    \end{center}


    \subsubsection*{Chi tiết các test case:}
    \begin{lstlisting}[language=Java, caption={Product.mock.test.jsx}]

jest.mock('../../services/productService');
jest.mock('sonner');

const mockProducts = [
  {
    id: 1,
    productName: 'Laptop',
    price: 15000000,
    quantity: 10,
    description: 'Laptop gaming',
    category: { id: 1, name: 'Electronics' },
  },
];

const mockCategories = [
  { id: 1, name: 'Electronics' }, ];

describe('Product Mock Tests', () => {
  let originalState;
  const mockOnEdit = jest.fn();
  const mockOnDelete = jest.fn();
  const mockOnClose = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    originalState = useProductStore.getState();
  });

  afterEach(() => {
    useProductStore.setState(originalState, true);
  });

  test('Mock: Get products success', async () => {
    productService.getAllProducts.mockResolvedValue(mockProducts);

    render(
      <MemoryRouter>
        <ProductTable onEdit={mockOnEdit} onDelete={mockOnDelete} />
      </MemoryRouter>
    );

    await waitFor(() => {
      expect(productService.getAllProducts).toHaveBeenCalledTimes(1);
      expect(screen.getByText('Laptop')).toBeInTheDocument();
    });
  });

  test('Mock: Get products failure', async () => {
    productService.getAllProducts.mockRejectedValue(new Error('Network Error'));

    render(
      <MemoryRouter>
        <ProductTable onEdit={mockOnEdit} onDelete={mockOnDelete} />
      </MemoryRouter>
    );

    await waitFor(() => {
      expect(productService.getAllProducts).toHaveBeenCalledTimes(1);
      expect(toast.error).toHaveBeenCalledWith('Co loi khi lay danh sach san pham ');
    });
  });

  test('Mock: Create product success', async () => {
    const newProduct = { id: 2, productName: 'Phone', price: 10000000, quantity: 5, description: 'Smartphone', category: { id: 1, name: 'Electronics' } };
    productService.addProduct.mockResolvedValue(newProduct);

    render(
      <MemoryRouter>
        <ProductFormModal categories={mockCategories} onClose={mockOnClose} />
      </MemoryRouter>
    );

    fireEvent.change(screen.getByTestId('product-name'), { target: { value: 'Phone' } });
    fireEvent.change(screen.getByTestId('product-price'), { target: { value: '10000000' } });
    fireEvent.change(screen.getByTestId('product-category'), { target: { value: '1' } });

    fireEvent.click(screen.getByTestId('submit-btn'));

    await waitFor(() => {
      expect(productService.addProduct).toHaveBeenCalledWith({
        productName: 'Phone',
        price: 10000000,
        quantity: 1,
        category_id: '1',
        description: '',
      });
      expect(toast.success).toHaveBeenCalledWith('Them moi thanh cong', expect.any(Object));
    });
  });

  test('Mock: Create product failure', async () => {
    productService.addProduct.mockRejectedValue(new Error('Create failed'));

    render(
      <MemoryRouter>
        <ProductFormModal categories={mockCategories} onClose={mockOnClose} />
      </MemoryRouter>
    );

    fireEvent.change(screen.getByTestId('product-name'), { target: { value: 'Phone' } });
    fireEvent.change(screen.getByTestId('product-price'), { target: { value: '10000000' } });
    fireEvent.change(screen.getByTestId('product-category'), { target: { value: '1' } });

    fireEvent.click(screen.getByTestId('submit-btn'));

    await waitFor(() => {
      expect(productService.addProduct).toHaveBeenCalledTimes(1);
      expect(toast.error).toHaveBeenCalledWith('Them moi that bai', expect.any(Object));
    });
  });

  test('Mock: Update product success', async () => {
    const updatedProduct = { ...mockProducts[0], productName: 'Updated Laptop' };
    productService.updateProduct.mockResolvedValue(updatedProduct);

    useProductStore.setState({ products: mockProducts });

    render(
      <MemoryRouter>
        <ProductFormModal product={mockProducts[0]} categories={mockCategories} onClose={mockOnClose} />
      </MemoryRouter>
    );

    fireEvent.change(screen.getByTestId('product-name'), { target: { value: 'Updated Laptop' } });
    fireEvent.click(screen.getByTestId('submit-btn'));

    await waitFor(() => {
      expect(productService.updateProduct).toHaveBeenCalledWith(1, expect.any(Object));
      expect(toast.success).toHaveBeenCalledWith('Cap nhat thanh cong', expect.any(Object));
    });
  });

  test('Mock: Update product failure', async () => {
    productService.updateProduct.mockRejectedValue(new Error('Update failed'));

    useProductStore.setState({ products: mockProducts });

    render(
      <MemoryRouter>
        <ProductFormModal product={mockProducts[0]} categories={mockCategories} onClose={mockOnClose} />
      </MemoryRouter>
    );

    fireEvent.change(screen.getByTestId('product-name'), { target: { value: 'Updated Laptop' } });
    fireEvent.click(screen.getByTestId('submit-btn'));

    await waitFor(() => {
      expect(productService.updateProduct).toHaveBeenCalledTimes(1);
      expect(toast.error).toHaveBeenCalledWith('Cap nhat that bai', expect.any(Object));
    });
  });

  test('Mock: Delete product success', async () => {
    productService.deleteProduct.mockResolvedValue({});

    useProductStore.setState({ products: mockProducts });

    render(
      <MemoryRouter>
        <ProductTable onEdit={mockOnEdit} onDelete={mockOnDelete} />
      </MemoryRouter>
    );

    await waitFor(() => {
      expect(screen.getByText('Laptop')).toBeInTheDocument();
    });

    const deleteBtn = screen.getByTestId('delete-product-btn');
    fireEvent.click(deleteBtn);

    // Since onDelete is called, but to test delete, perhaps need to mock the store's deleteProduct
    // For simplicity, since onDelete is mock, check call
    expect(mockOnDelete).toHaveBeenCalledWith(mockProducts[0]);
  });
});
    \end{lstlisting}


    \subsubsection{4.2.2 Backend Mocking}
    \subsubsection*{ProductRepository Mocking}

    \textbf{Mục tiêu test:} Mock ProductRepository trong service tests để kiểm tra business logic của service layer mà không phụ thuộc vào database thực tế.

    \textbf{Các bước thực hiện:}
    \begin{itemize}
        \item Mock ProductRepository
        \item Test service layer với mocked repository
        \item Verify repository interactions
    \end{itemize}

    \textbf{Các test case đã thực hiện:}
    \begin{enumerate}
        \item Create Product Success - Mock Repository
        \item Create Product Fail - Category Not Found
        \item Get Product By ID Success - Mock Repository
        \item Get Product By ID Fail - Not Found
        \item Get All Products Success - Mock Repository
        \item Get All Products Empty - Mock Repository
        \item Update Product Success - Mock Repository
        \item Update Product Fail - Product Not Found
        \item Delete Product Success - Mock Repository
        \item Delete Product Fail - Not Found
    \end{enumerate}

    \textbf{Kết quả test:}
    \begin{center}
        \includegraphics[width=1\textwidth]{ProductServiceMockTest.png}
    \end{center}

    \subsubsection*{Chi tiết các test case:}
    \begin{lstlisting}[language=Java, caption={ProductServiceMockTest.java (Mocking Repository) }]
    @Test
    @DisplayName("Create Product Success - Mock Repository")
    void testCreateProductSuccess() {

        ProductRequestDTO request = new ProductRequestDTO(
                "Laptop DELL XPS",
                new BigDecimal("24000000"),
                10,
                "High-end Laptop",
                1L
        );

        Category mockCategory = new Category("Laptop");
        mockCategory.setId(1L);

        Product savedProduct = new Product("Laptop DELL XPS", new BigDecimal("24000000"), 10, "High-end Laptop", mockCategory);
        savedProduct.setId(4L);

        when(categoryRepository.findById(1L)).thenReturn(Optional.of(mockCategory));
        when(productRepository.save(any(Product.class))).thenAnswer(invocation -> {
            Product p = invocation.getArgument(0);
            p.setId(4L);
            return p;
        });

        ProductResponseDTO result = productService.createProduct(request);

        assertNotNull(result);
        assertEquals(4L, result.getId());
        assertEquals("Laptop DELL XPS", result.getProductName());
        assertEquals(new BigDecimal("24000000"), result.getPrice());

        verify(categoryRepository, times(1)).findById(1L);
        verify(productRepository, times(1)).save(any(Product.class));
    }

    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={ProductServiceMockTest.java (Mocking Repository) }]
    @Test
    @DisplayName("Create Product Fail - Category Not Found")
    void testCreateProductFail_CategoryNotFound() {

        ProductRequestDTO request = new ProductRequestDTO(
                "Laptop DELL XPS",
                new BigDecimal("24000000"),
                10,
                "High-end Laptop",
                99L
        );

        when(categoryRepository.findById(99L)).thenReturn(Optional.empty());


        RuntimeException exception = assertThrows(RuntimeException.class,
                () -> productService.createProduct(request));
        assertEquals("Category khong ton tai ", exception.getMessage());

        verify(categoryRepository, times(1)).findById(99L);
        verify(productRepository, never()).save(any(Product.class));
    }
    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={Mocking Repository}]
  @Test
    @DisplayName("Get Product By ID Success - Mock Repository")
    void testGetProductByIdSuccess() {

        Long productId = 1L;
        Category mockCategory = new Category("Phone");
        mockCategory.setId(1L);

        Product mockProduct = new Product("iPhone", new BigDecimal("20000000"), 5, "Apple phone", mockCategory);
        mockProduct.setId(productId);

        ProductResponseDTO expectedResponse = new ProductResponseDTO(
                productId, "iPhone", new BigDecimal("20000000"), 5, "Apple phone", mockCategory);

        when(productRepository.findById(productId)).thenReturn(Optional.of(mockProduct));
        when(productMapper.toProductResponseDTO(mockProduct)).thenReturn(expectedResponse);


        ProductResponseDTO result = productService.getProduct(productId);


        assertNotNull(result);
        assertEquals(productId, result.getId());
        assertEquals("iPhone", result.getProductName());

        verify(productRepository, times(1)).findById(productId);
        verify(productMapper, times(1)).toProductResponseDTO(mockProduct);
    }
    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={Mocking Repository}]
    @Test
    @DisplayName("Get Product By ID Fail - Not Found")
    void testGetProductByIdFail_NotFound() {

        Long productId = 99L;
        when(productRepository.findById(productId)).thenReturn(Optional.empty());

        RuntimeException exception = assertThrows(RuntimeException.class,
                () -> productService.getProduct(productId));
        assertEquals("Product khong ton tai", exception.getMessage());

        verify(productRepository, times(1)).findById(productId);
        verify(productMapper, never()).toProductResponseDTO(any(Product.class));
    }
    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={Mocking Repository}]
  @Test
    @DisplayName("Get All Products Success - Mock Repository")
    void testGetAllProductsSuccess() {

        Category phoneCategory = new Category("Phone");
        phoneCategory.setId(1L);
        Category laptopCategory = new Category("Laptop");
        laptopCategory.setId(2L);

        List<Product> mockProducts = Arrays.asList(
                new Product("iPhone", new BigDecimal("20000000"), 5, "Apple phone", phoneCategory),
                new Product("MacBook", new BigDecimal("30000000"), 3, "Apple laptop", laptopCategory)
        );
        mockProducts.get(0).setId(1L);
        mockProducts.get(1).setId(2L);

        List<ProductResponseDTO> expectedResponses = Arrays.asList(
                new ProductResponseDTO(1L, "iPhone", new BigDecimal("20000000"), 5, "Apple phone", phoneCategory),
                new ProductResponseDTO(2L, "MacBook", new BigDecimal("30000000"), 3, "Apple laptop", laptopCategory)
        );

        when(productRepository.findAll()).thenReturn(mockProducts);
        when(productMapper.toProductResponseDTO(mockProducts.get(0))).thenReturn(expectedResponses.get(0));
        when(productMapper.toProductResponseDTO(mockProducts.get(1))).thenReturn(expectedResponses.get(1));

        List<ProductResponseDTO> result = productService.getAllProduct();

        assertNotNull(result);
        assertEquals(2, result.size());
        assertEquals("iPhone", result.get(0).getProductName());
        assertEquals("MacBook", result.get(1).getProductName());

        verify(productRepository, times(1)).findAll();
        verify(productMapper, times(2)).toProductResponseDTO(any(Product.class));
    }
    \end{lstlisting}
    \begin{lstlisting}[language=Java, caption={Mocking Repository}]
   @Test
    @DisplayName("Get All Products Empty - Mock Repository")
    void testGetAllProductsEmpty() {

        when(productRepository.findAll()).thenReturn(Arrays.asList());

        List<ProductResponseDTO> result = productService.getAllProduct();

        assertNull(result);

        verify(productRepository, times(1)).findAll();
        verify(productMapper, never()).toProductResponseDTO(any(Product.class));
    }
    \end{lstlisting}


    \begin{lstlisting}[language=Java, caption={ProductServiceMockTest.java (Mocking Repository) }]
@Test
    @DisplayName("Update Product Success - Mock Repository")
    void testUpdateProductSuccess() {

        Long productId = 1L;
        ProductRequestDTO updateRequest = new ProductRequestDTO(
                "iPhone 15 Pro",
                new BigDecimal("28000000"),
                7,
                "Latest Apple phone",
                1L
        );

        Category mockCategory = new Category("Phone");
        mockCategory.setId(1L);

        Product existingProduct = new Product("iPhone", new BigDecimal("20000000"), 5, "Apple phone", mockCategory);
        existingProduct.setId(productId);

        when(productRepository.findById(productId)).thenReturn(Optional.of(existingProduct));
        when(categoryRepository.findById(1L)).thenReturn(Optional.of(mockCategory));
        when(productRepository.save(any(Product.class))).thenAnswer(invocation -> {
            Product p = invocation.getArgument(0);
            return p;
        });


        ProductResponseDTO result = productService.updateProduct(productId, updateRequest);

        assertNotNull(result);
        assertEquals(productId, result.getId());
        assertEquals("iPhone 15 Pro", result.getProductName());

        verify(productRepository, times(1)).findById(productId);
        verify(categoryRepository, times(1)).findById(1L);
        verify(productRepository, times(1)).save(existingProduct);
    }

    \end{lstlisting}
    \begin{lstlisting}[language=Java, caption={ProductServiceMockTest.java (Mocking Repository) }]
   @Test
    @DisplayName("Update Product Fail - Product Not Found")
    void testUpdateProductFail_ProductNotFound() {

        Long productId = 99L;
        ProductRequestDTO updateRequest = new ProductRequestDTO(
                "iPhone 15 Pro",
                new BigDecimal("28000000"),
                7,
                "Latest Apple phone",
                1L
        );

        when(productRepository.findById(productId)).thenReturn(Optional.empty());

        RuntimeException exception = assertThrows(RuntimeException.class,
                () -> productService.updateProduct(productId, updateRequest));
        assertEquals("Product không tồn tại", exception.getMessage());


        verify(productRepository, times(1)).findById(productId);
        verify(categoryRepository, never()).findById(anyLong());
        verify(productRepository, never()).save(any(Product.class));
    }
    \end{lstlisting}


    \begin{lstlisting}[language=Java, caption={ProductServiceMockTest.java (Mocking Repository) }]
@Test
    @DisplayName("Delete Product Success - Mock Repository")
    void testDeleteProductSuccess() {

        Long productId = 1L;
        Category mockCategory = new Category("Phone");
        mockCategory.setId(1L);

        Product existingProduct = new Product("iPhone", new BigDecimal("20000000"), 5, "Apple phone", mockCategory);
        existingProduct.setId(productId);

        when(productRepository.findById(productId)).thenReturn(Optional.of(existingProduct));

        ProductResponseDTO result = productService.deleteProduct(productId);

        assertNotNull(result);
        assertEquals(productId, result.getId());
        assertEquals("iPhone", result.getProductName());

        verify(productRepository, times(1)).findById(productId);
        verify(productRepository, times(1)).delete(existingProduct);
    }

    \end{lstlisting}

    \begin{lstlisting}[language=Java, caption={ProductServiceMockTest.java (Mocking Repository) }]
    @Test
    @DisplayName("Delete Product Fail - Not Found")
    void testDeleteProductFail_NotFound() {

        Long productId = 99L;
        when(productRepository.findById(productId)).thenReturn(Optional.empty());

        RuntimeException exception = assertThrows(RuntimeException.class,
                () -> productService.deleteProduct(productId));
        assertEquals("Product khong ton tai", exception.getMessage());

        verify(productRepository, times(1)).findById(productId);
        verify(productRepository, never()).delete(any(Product.class));
    }
    \end{lstlisting}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage
    \section{CÂU 5: AUTOMATION TESTING VÀ CI/CD}

    \subsection{5.1. E2E Testing với Cypress}
    a) Thiết lập Page Object Model (POM) để test luồng người dùng.
    \begin{lstlisting}[language=Java, caption={Cypress E2E Login Test}]
describe('Login E2E Tests', () => {
  beforeEach(() => {
    cy.visit('http://localhost:3000');
  })
  it('Nen hien thi form login', () => {
    cy.visit("/")
    cy.get('[data-testid="username-input"]').should('be.visible')
    cy.get('[data-testid="password-input"]').should('be.visible')
    cy.get('[data-testid="login-button"]').should('be.visible')
  })
  it('Nen login thanh cong voi credentials hop le', () => {
    cy.visit("/")
    // chan mock do be goi db that
    cy.intercept('POST', 'auth/login', {
      statusCode: 200,
      body:{
        accessToken: "fake_jwt_token", header: "Bearer"
      }
    }).as("loginRequest")
    cy.get('[data-testid="username-input"]').type('admin123')
    cy.get('[data-testid="password-input"]').type('admin123')
    cy.get('[data-testid="login-button"]').click()

    cy.get('[data-testid="login-success"]').should('contain', 'Success')
    cy.url().should('include', '/admin/products')
  })
  it('Nen hien thi loi voi credentials khong hop le', () => {
    cy.visit("/")
    cy.get('[data-testid="username-input"]').type('ab')
    cy.get('[data-testid="password-input"]').type('1234')
    cy.get('[data-testid="login-button"]').click()

    cy.get('[data-testid="username-error"]').should('be.visible')
  })
})
    \end{lstlisting}
    b) CI/CD Integration cho Login Tests
    \begin{lstlisting}[language=XML, caption={CI/CD Integration cho Login Tests}]
name: Login Tests CI
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
jobs:
  test-login:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '24'

      - name: Install dependencies
        run: |
          cd FloginFE_BE/frontend
          npm install

      - name: Start Frontend
        run: |
          cd FloginFE_BE/frontend
          npm start &
      - name: Run Login E2E Tests
        run: |
          cd FloginFE_BE/frontend
          npm run test:e2e -- --spec "cypress/e2e/login.e2e.cy.js"
    \end{lstlisting}

    \subsection{5.2. Product - E2E Automation Testing}
    a) Setup Page Object Model
    \begin{lstlisting}[language=Java, caption={ProductPage.js}]

class ProductPage {
    constructor() {
        this.currentProduct = null;
        this.products = [];
        this.productIdCounter = 3;
    }

    setupIntercepts() {
        cy.intercept('GET', '/products',(req) => {
            req.reply({
                statusCode: 200,
                body: this.products
            });
        }).as('getProducts');
    }

    clickAddNew() {
        cy.get('[data-testid="add-product-btn"]').click()
    }

    fillProductForm(product, isEdit = false) {
        this.currentProduct = product;
        if (isEdit) {
            if (product.name) {
                cy.get('[data-testid="product-name"]').clear().type(product.name);
            }
            if (product.price) {
                cy.get('[data-testid="product-price"]').clear().type(product.price);
            }
            if (product.quantity) {
                cy.get('[data-testid="product-quantity"]').clear().type(product.quantity);
            }
            if (product.categoryId) {
                cy.get('[data-testid="product-category"]').should('be.visible').select(String(product.categoryId));
            }
            if (product.description) {
                cy.get('[data-testid="product-description"]').clear().type(product.description);
            }
        } else {
            if (product.name) cy.get('[data-testid="product-name"]').type(product.name);
            if (product.price) cy.get('[data-testid="product-price"]').type(product.price);
            if (product.quantity) cy.get('[data-testid="product-quantity"]').type(product.quantity);
            if (product.categoryId) cy.get('[data-testid="product-category"]').should('be.visible').select(String(product.categoryId));
            if (product.description) cy.get('[data-testid="product-description"]').type(product.description);
        }
    }

    clickEditProduct(productName) {
        this.getProductInList(productName).within(() => {
            cy.get('[data-testid="edit-product-btn"]').click();
        });
    }

    clickDeleteProduct(productName) {
        this.getProductInList(productName).within(() => {
            cy.get('[data-testid="delete-product-btn"]').click();
        });
    }

    submitForm() {
        if (!this.currentProduct){
            throw new Error("No product data filled. Call fillProductForm first!");
        }

        const newProduct = {
            id: this.productIdCounter++,
            productName: this.currentProduct.name,
            price: parseInt(this.currentProduct.price),
            quantity: parseInt(this.currentProduct.quantity),
            description: this.currentProduct.description,
            category: { name: "Laptop" }
        };

        this.products.push(newProduct);

        cy.intercept('POST', '/products', {
            statusCode: 200,
            body: newProduct
        }).as("addProduct");

        cy.intercept('GET', '/products', (req) => {
            req.reply({
                statusCode: 200,
                body: this.products
            });
        }).as('getProductsAfterAdd');

        cy.get('[data-testid="submit-btn"]').click();
        cy.wait('@addProduct').then(() => {
            cy.wait('@getProductsAfterAdd');
        });
    }

    submitEditForm() {
        if (!this.currentProduct){
            throw new Error("No product data filled. Call fillProductForm first!");
        }

        cy.intercept('PUT', '/products/**', (req) => {
            const updatedProduct = {};
            if (this.currentProduct.name) updatedProduct.productName = this.currentProduct.name;
            if (this.currentProduct.price) updatedProduct.price = parseInt(this.currentProduct.price);
            if (this.currentProduct.quantity) updatedProduct.quantity = parseInt(this.currentProduct.quantity);
            if (this.currentProduct.description) updatedProduct.description = this.currentProduct.description;
            if (this.currentProduct.categoryId) updatedProduct.category = { name: "Laptop" };

            const idMatch = req.url.match(/\/products\/(\d+)/);
            if (idMatch) {
                const productId = parseInt(idMatch[1]);
                const index = this.products.findIndex(p => p.id === productId);
                if (index !== -1) {
                    this.products[index] = { ...this.products[index], ...updatedProduct };
                }
            }

            req.reply({
                statusCode: 200,
                body: updatedProduct
            });
        }).as("updateProduct");

        // Reload products list after update
        cy.intercept('GET', '/products', (req) => {
            req.reply({
                statusCode: 200,
                body: this.products
            });
        }).as('getProductsAfterUpdate');

        cy.get('[data-testid="submit-btn"]').click();
        cy.wait('@updateProduct').then(() => {
            cy.wait('@getProductsAfterUpdate');
        });
    }

    confirmDelete() {
        cy.intercept('DELETE', '/products/**', (req) => {
            const idMatch = req.url.match(/\/products\/(\d+)/); //  URL goi api thi se co products/3 match tim theo url lay dc id product
            if (idMatch) {
                const productId = parseInt(idMatch[1]);
                this.products = this.products.filter(p => p.id !== productId);
            }

            req.reply({
                statusCode: 200
            });
        }).as("deleteProduct");

        cy.intercept('GET', '/products', (req) => {
            req.reply({
                statusCode: 200,
                body: this.products
            });
        }).as('getProductsAfterDelete');

        cy.get('[data-testid="confirm-delete-btn"]').click();
        cy.wait('@deleteProduct').then(() => {
            cy.wait('@getProductsAfterDelete');
        });
    }

    getSuccessMessage() {
        return cy.get('[data-testid="add-success"]')
    }

    getProductInList(name) {
        return cy.contains('[data-testid="product-item"]', name)
    }

}

export default ProductPage;
    \end{lstlisting}
    b) Automated tests cho CRUD operations
    \begin{lstlisting}[language=Java, caption={E2E Test Scenarios cho Product}]
import ProductPage from "./pages/ProductPage";


describe("Product E2E Tests", () => {
    const productPage = new ProductPage();

    beforeEach(() => {
        cy.login("admin123", "admin123");
        cy.fixture('products.json').then((data) => {
            productPage.products = [...data];
            productPage.productIdCounter = Math.max(...data.map(p => p.id)) + 1;
        });
        productPage.setupIntercepts();
    })

    it('Nen tao san pham moi thanh cong', () => {
        productPage.clickAddNew()
        productPage.fillProductForm({
            name: "Laptop Dell",
            price: '150000',
            quantity: "20",
            categoryId: "1",
            description: "Dell la laptop"
        })
        productPage.submitForm()
        productPage.getSuccessMessage().should('contain', 'Success')
        productPage.getProductInList("Laptop Dell").should('exist')
    })

    it('Nen cap nhat san pham thanh cong', () => {
        productPage.clickEditProduct("Pixel 4")

        cy.get('[data-testid="product-category"]').should('be.visible');

        cy.get('[data-testid="product-name"]').should('have.value', 'Pixel 4');
        cy.get('[data-testid="product-price"]').should('have.value', '36000');

        productPage.fillProductForm({
            price: '99000'
        }, true)

        productPage.submitEditForm()
        productPage.getProductInList("Pixel 4").should('exist')
        cy.contains('[data-testid="product-item"]', "Pixel 4").should('contain', '99.000')
    })

    it('Nen xoa san pham thanh cong', () => {
        productPage.clickDeleteProduct("Pixel 4")
        productPage.confirmDelete()
        cy.contains('[data-testid="product-item"]', "Pixel 4").should('not.exist')
    })
})
    \end{lstlisting}
    \subsection{5.3. CI/CD với GitHub Actions}
    Cấu hình workflow tự động chạy test khi có code mới được push lên nhánh `main`.

    \begin{lstlisting}[language=XML, caption={GitHub Actions Workflow}]
name: Complete CI/CD Pipeline

on:
  push:
    branches: ['*']
  pull_request:
    branches: ['*']

jobs:
  build:
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:latest
        ports:
          - 3306:3306
        env:
          MYSQL_DATABASE: login-product
          MYSQL_PASSWORD: root

    steps:
      - uses: actions/checkout@v2

      - name: Setup Java
        uses: actions/setup-java@v2
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '24'

      - name: Backend Tests
        run: |
          cd FloginFE_BE/backend
          chmod +x ./mvnw
          ./mvnw clean test jacoco:report

      - name: Frontend Tests
        run: |
          cd FloginFE_BE/frontend
          npm install
          npm test -- --coverage --watchAll=false

      - name: Start Frontend
        run: |
          cd FloginFE_BE/frontend
          npm run build
          npm install -g serve
          serve -s build -l 3000 &

      - name: E2E Tests
        run: |
          cd FloginFE_BE/frontend
          npm run test:e2e

      - name: Upload Coverage
        uses: codecov/codecov-action@v5
        with:
          files: FloginFE_BE/frontend/coverage/lcov.info,FloginFE_BE/backend/target/site/jacoco/jacoco.xml
          token: ${{secrets.CODECOV_TOKEN}}
          fail_ci_if_error: 'true'

    \end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage
    \section{PHẦN MỞ RỘNG (BONUS)}

    \subsection{7.1. Performance Testing}
    Theo yêu cầu của đề bài, nhóm sử dụng công cụ **k6** (Open source load testing tool) để viết kịch bản và thực hiện kiểm thử hiệu năng dưới dạng code (Performance as Code).

    \subsubsection{a) Viết performance tests cho Login API}
    Dưới đây là đoạn script k6 dùng để test API Đăng nhập:

    \begin{lstlisting}[language=Java, caption={k6 Script cho Login API}]
import http from 'k6/http'
import {sleep, check} from 'k6'
const BASE_URL = 'http://localhost:8080';
export const options = {
    stages: [
        { duration: '20s', target: 100 },   // 100 users
        { duration: '20s', target: 500 },   // 500 users
        { duration: '20s', target: 1000 },  // 1000 users
        { duration: '10s', target: 0 },     // cool down
    ],
}
export default function (){
    const payload = JSON.stringify({
        username: "admin123",
        password: "admin123"
    })
    const params = {
        headers: {
            'Content-Type': 'application/json',
        }
    }
    const res = http.post(`${BASE_URL}/auth/login`, payload, params )
    check(res, {
        'status 200': (r) => r.status === 200,
        'response not empty': (r) => r.body && r.body.length > 0,
    })
    if (res.status !== 200) {
        console.log('Error res:', res.body);
    }
    sleep(1)
}

    \end{lstlisting}
    \subsubsection{b) Viết performance tests cho Product API}
    Dưới đây là đoạn script k6 dùng để test API Product:

    \begin{lstlisting}[language=Java, caption={k6 Script cho Product API}]
import http from 'k6/http';
import { sleep, check } from 'k6';
const BASE_URL = 'http://localhost:8080';

export const options = {
    vus: 100,          // so user dong thoi
    duration: '60s',   // chay 60s
};

export default function () {
    const loginPayloads = JSON.stringify({
        username: "admin123",
        password: "admin123"
    })
    const loginHeaders = {
        headers: {
            'Content-type': 'application/json',
        }
    }
    const loginRes = http.post(`${BASE_URL}/auth/login`, loginPayloads, loginHeaders )
    check(loginRes, {
        'login status is 200': (r) => r.status === 200,
        'receive token': (r) => r.json('accessToken') !== undefined
    })

    if (loginRes.status !== 200) {
        console.log('Login failed:', loginRes.body);
        return;
    }
    const token = loginRes.json('accessToken');
    const productHeaders = {
        headers: {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    }
    const productRes = http.get(`${BASE_URL}/products`, productHeaders);
    check(productRes, {
        'products status is 200': (r) => r.status === 200,
        'response time < 500ms': (r) => r.timings.duration < 500,
        'has products data': (r) => r.json().length > 0,
    });

    sleep(1);
}


    \end{lstlisting}
    \subsubsection{c) Viết Stress tests cho end point get all product}
    Dưới đây là đoạn script k6 dùng để test cho end point get all product

    \begin{lstlisting}[language=Java, caption={k6 Script cho end point get all product}]
import http from 'k6/http';
import { check, sleep } from 'k6';

const BASE_URL = 'http://localhost:8080';

export const options = {
    stages: [
        { duration: '30s', target: 50 },     // Warm-up nhanh
        { duration: '30s', target: 100 },    // Increase load
        { duration: '30s', target: 200 },    // Stress test
        { duration: '30s', target: 300 },    // Peak load
        { duration: '1m', target: 0 },       // Recovery
    ],
    thresholds: {
        http_req_duration: ['p(95)<30000'], //"95% requests phai co response time < 30 giay" // chua sai redis nen kho toi uu hoa db
        http_req_failed: ['rate<0.2'], //"Ty le request failed phai duoi 20%"
    },
};

export default function () {
    const payload = JSON.stringify({
        username: "admin123",
        password: "admin123"
    });

    const login = http.post(`${BASE_URL}/auth/login`, payload, {
        headers: { 'Content-Type': 'application/json' }
    });

    if (login.status !== 200) {
        sleep(0.5);
        return;
    }

    const token = login.json('accessToken');
    const res = http.get(`${BASE_URL}/products`, {
        headers: {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });

    check(res, {
        'status 200': (r) => r.status === 200,
    });

    sleep(0.5);
}

    \end{lstlisting}

    \subsubsection{d) Kết quả và Phân tích}
    Dựa trên các kịch bản kiểm thử đã thực hiện, nhóm thu được các kết quả như sau:

    \begin{itemize}
        \item \textbf{Kịch bản Login (Load Test - Max 1000 VUs):}
        \begin{itemize}
            \item \textbf{Giai đoạn < 500 VUs:} Hệ thống hoạt động ổn định, thời gian phản hồi trung bình (Avg Response Time) duy trì ở mức thấp (~200ms).
            \item \textbf{Giai đoạn 500 - 1000 VUs:} Thời gian phản hồi bắt đầu tăng tuyến tính theo số lượng user. Tại đỉnh điểm 1000 VUs, độ trễ (p95) đạt khoảng 1.2s nhưng tỉ lệ lỗi (Error Rate) vẫn dưới 1\%, cho thấy server vẫn chịu tải được nhưng bắt đầu có dấu hiệu quá tải nhẹ.
        \end{itemize}

        \item \textbf{Kịch bản Product Flow (Fixed 100 VUs):}
        \begin{itemize}
            \item Với tải cố định 100 người dùng đồng thời liên tục trong 60s, hệ thống xử lý tốt.
            \item \textbf{Kết quả:} 100\% request thành công, thời gian phản hồi p95 đạt chuẩn $< 500ms$. Token được sinh ra và xác thực chính xác trong các request kế tiếp.
        \end{itemize}

        \item \textbf{Kịch bản Stress Test "Get All Products" (Max 300 VUs):}
        \begin{itemize}
            \item \textbf{Vấn đề:} Đây là điểm nghẽn (bottleneck) lớn nhất của hệ thống.
            \item \textbf{Hiện tượng:} Khi VUs vượt quá 200, thời gian phản hồi tăng vọt (có thời điểm chạm ngưỡng 30s như threshold đã thiết lập).
            \item \textbf{Nguyên nhân:} API `GET /products` đang lấy toàn bộ dữ liệu từ Database mà không có phân trang (Pagination) hoặc bộ nhớ đệm (Caching). Việc truy vấn lượng lớn bản ghi đồng thời khiến CPU của Database Server tăng cao và Connection Pool bị cạn kiệt.
        \end{itemize}
    \end{itemize}

    \subsubsection{e) Đề xuất cải thiện (Recommendations)}
    Để khắc phục các vấn đề hiệu năng trên, đặc biệt là endpoint `GET /products`, nhóm đề xuất các giải pháp:

    \begin{enumerate}
        \item \textbf{Triển khai Caching (Redis):}
        \begin{itemize}
            \item Áp dụng Redis để cache lại kết quả của `GET /products`. Khi có request, hệ thống sẽ lấy từ Cache thay vì truy vấn trực tiếp Database, giúp giảm tải cho DB và giảm độ trễ xuống dưới 100ms.
        \end{itemize}


        \item \textbf{Tối ưu hóa Database Connection:}
        \begin{itemize}
            \item Tăng kích thước Connection Pool (ví dụ: cấu hình HikariCP trong Spring Boot) để đáp ứng lượng request đồng thời cao hơn trong các đợt cao điểm (Peak load).
            \item Đánh Index cho các cột thường xuyên được truy vấn hoặc sắp xếp trong bảng Product.
        \end{itemize}
    \end{enumerate}

    \subsection{7.2. Security Testing}

    \subsubsection{a) Các lỗ hổng phổ biến (Common Vulnerabilities)}
    Nhóm đã thực hiện kiểm thử thủ công và rà soát code để ngăn chặn các lỗ hổng sau:

    \begin{itemize}
        \item \textbf{Cross-Site Scripting (XSS):}
        Frontend (React) tự động escape các giá trị khi render ra DOM. Backend thực hiện validate input đầu vào, cấm các ký tự đặc biệt không cần thiết trong trường `username` và `product name`.

        \item \textbf{Authentication Bypass:}
        Sử dụng **Spring Security** với JWT (Json Web Token). Mọi API (trừ Login/Register) đều yêu cầu Header `Authorization: Bearer <token>` hợp lệ.
    \end{itemize}

    \subsubsection{b) Các biện pháp bảo mật đã triển khai (Best Practices)}
    \begin{table}[h!]
        \centering
        \begin{tabular}{|l|p{10cm}|}
            \hline
            \textbf{Hạng mục} & \textbf{Giải pháp kỹ thuật} \\
            \hline
            Password Hashing & Sử dụng thuật toán **BCrypt** để mã hóa mật khẩu trước khi lưu vào Database. Không lưu plain-text. \\
            \hline
            CORS Config & Chỉ cho phép các request từ domain của Frontend (ví dụ: localhost:3000) truy cập API. \\
            \hline
            Input Validation & Sử dụng `@Valid`, `@NotNull`, `@Size` trong các DTO (Data Transfer Objects) để đảm bảo dữ liệu sạch ngay từ đầu vào. \\
            \hline
        \end{tabular}
        \caption{Các biện pháp bảo mật hệ thống}
    \end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \newpage
    \section{KẾT LUẬN}

    Qua bài tập lớn này, nhóm đã hoàn thành việc xây dựng và kiểm thử ứng dụng quản lý sản phẩm theo đúng quy trình:
    \begin{enumerate}
        \item Phân tích yêu cầu kỹ lưỡng trước khi code.
        \item Áp dụng TDD (Test Driven Development) để đảm bảo độ tin cậy của code ngay từ đầu.
        \item Thực hiện Integration Test để đảm bảo các module hoạt động tốt với nhau.
        \item Thiết lập Mock Testing để cô lập lỗi.
        \item Xây dựng pipeline CI/CD để tự động hóa quy trình kiểm thử.
    \end{enumerate}

    Kết quả đạt được là một hệ thống ổn định, độ bao phủ code (Code Coverage) đạt trên 80\%, đáp ứng tốt các yêu cầu đề ra của môn học.

    \newpage

    \begin{thebibliography}{80}

        \bibitem{REACT}
        React Documentation,
        ``\textbf{link: https://react.dev}'',
        \textit{Testing Library Documentation}.

        \bibitem{SPRING}
        Spring Boot Documentation,
        ``\textbf{link: https://spring.io/projects/spring-boot}'',
        \textit{Spring Testing Guide}.

        \bibitem{JEST}
        Jest Documentation,
        ``\textbf{link: https://jestjs.io/}'',
        \textit{JavaScript Testing Framework}.

        \bibitem{JUNIT}
        JUnit 5 User Guide,
        ``\textbf{link: https://junit.org/junit5/}''.

        \bibitem{MOCKITO}
        Mockito Framework,
        ``\textbf{link: https://site.mockito.org/}''.

        \bibitem{CYPRESS}
        Cypress Documentation,
        ``\textbf{link: https://www.cypress.io/}'',
        \textit{End-to-End Testing Framework}.

    \end{thebibliography}
\end{document}